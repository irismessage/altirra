<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="index.xsl" ?>
<topic title="Custom device specification, v0.3">
  <toc/>
  <h2>Basic device description structure</h2>
  <p>
    An .atdevice file is a text file that describes the device and its core
    functionality. The file consists of a series of declarations which describe
    the parts of the custom device:
  </p>
  <pre>  // Comment
  option "name": "My custom device";

  Segment status_seg: {
      size: 4
  };

  function void init_status() {
      status_seg.write_byte(3, $E0);
  }

  event "cold_reset": function {
      init_status();
  }</pre>

  <p>
    The file is mostly processed in order from the beginning. Except for cases where one section
    refers to another, sections can generally be mixed in any order within the device description file.
  </p>

  <h3>Top-level statements</h3>
  <p>
    At the top level, the device description is a series of statements. Each statement ends with
    a semicolon, no matter how many lines it spans. The exception is a function, which ends with a closing
    brace without a semicolon; this is to be syntactically familiar to the C programming language.
  </p>

  <h3>Literal values</h3>
  <p>
    Integer constants can be specified either as decimal or hexadecimal (base 16). Hex constants are prefixed
    with <tt>$</tt> (not <tt>0x</tt>).
  </p>
  <p>
    String constants are specified within double quotes, e.g. <tt>"abc"</tt>.
  </p>

  <h3>Variables</h3>
  <p>
    Variables are used to store values used or modified by a device, as well as objects used to interact with
    the host emulation. Variables are <i>statically typed</i>: they are always defined with a type and can only ever
    hold values of that type.
  </p>
  <p>
    There are two types of variables. Variables of primitive type, currently only type <tt>int</tt>, are
    modifiable by script and used to hold device state. These are described in the Scripting section.
    They may also be of class object type, such as <tt>Segment</tt> for data segments, or <tt>MemoryLayer</tt>
    for emulation memory layers. Defining a variable of object type usually unlocks behaviors in the custom
    device, such as enabling serial I/O bus support.
  </p>
  <p>
    Variable names start with a letter or an underscore (<tt>_</tt>), followed by zero or more letters,
    numbers, or underscores. A variable name cannot contain spaces, dollar signs (<tt>$</tt>), or non-ASCII
    characters. Both lower and upper case may be used in variable names, and case is significant: <tt>abc</tt>
    and <tt>Abc</tt> are different variables. Variables must have unique names even if they are of different
    types.
  </p>
  <p>
    The following names are reserved as keywords in a device file and are not available as variable names:
  </p>
  <table border="0" class="cd-keywords">
    <tr>
      <td>else</td>
      <td>event</td>
      <td>false</td>
      <td>function</td>
    </tr>
    <tr>
      <td>if</td>
      <td>int</td>
      <td>loop</td>
      <td>option</td>
    </tr>
    <tr>
      <td>return</td>
      <td>true</td>
      <td>void</td>
    </tr>
  </table>
  <p>
    A global variable is declared at top-level with the type followed by the variable name, and ending
    with a semicolon:
  </p>
  <pre>  int current_bank;
  Thread recv_thread;</pre>

  <h3>Functions</h3>
  <p>
    <i>Functions</i> hold statements that drive device logic. They are declared using the <tt>function</tt>
    keyword:
  </p>
  <pre>  function void reset_bank() {
      bank = 0;
  }</pre>
  <p>
    These are described in more detail in the Scripting section. A function by itself does nothing unless
    it is called, typically from an event handler or a memory access binding.
  </p>

  <h3>Structured data</h3>
  <p>
    Many object types require structured data to configure the object when it is created. This
    is specified with a colon after the variable name, followed by the data:
  </p>
  <pre>  Segment status_buffer: { size: 4 };</pre>
  <p>
    The object data is structured similarly to JSON, with some syntax adaptations. The top-level data
    value can be a boolean (<tt>true</tt> or <tt>false</tt>), an integer, a function, a variable, an array, or an data object.
    Arrays and data objects can in turn contain sub-values, creating a tree of nested values.
  </p>
  <p>
    Arrays are specified with <tt>[brackets]</tt> and contain a comma-separated list of sub-values,
    e.g. <tt>[1, 2, "abc"]</tt>. The values may be of different types. The array can also be empty: <tt>[]</tt>.
  </p>
  <p>
    Data objects are contained within <tt>{braces}</tt> and have a comma-separated list of named members. Each
    member is specified with the form <tt>name: value</tt>, where the name is a valid variable name. <tt>{ x: 4, y: 7 }</tt>
    and <tt>{}</tt> are valid data objects. Member names must be unique within an object. Unlike in JSON, however, the name is not quoted.
  </p>
  <p>
    Variables are referenced in a few cases within object data, particularly to connect to segments. These
    are simply specified by the variable name without quotes.
  </p>
  <p>
    Finally, object data may have inline script functions, which are small fragments of script code within
    the object data itself. The syntax is <tt>function { ... }</tt>, where the body of the function is
    specified within the braces.
  </p>

  <h3>Options</h3>
  <p>
    The <tt>option</tt> statement is used to set miscellaneous device parameters. The syntax is:
  </p>
  <blockquote>
    <tt>option "</tt><i>option-name</i><tt>": </tt><i>option-value</i><tt>;</tt>
  </blockquote>
  <p>
    The option value is a structured data value which depends on the option. One option is <tt>"name"</tt>,
    which is a string that determines the display name of the device in UI. Another is <tt>"network"</tt>,
    which enables a connection to the network server.
  </p>
  
  <h3>Comments and whitespace</h3>
  <p>
    Most constructs in device descriptions are terminated by a semicolon or delimited by braces and are
    insensitive to whitespace and layout. A statement or definition can be freely split across as many
    lines as necessary. Indentation may also be used without affecting the meaning of the definitions or
    code. Either hard tabs or soft tabs (spaces) can be used.
  </p>
  <p>
    Comments start with two forward slashes (<tt>//</tt>). Everything from that point to the end of the
    line is ignored.
  </p>

  <h2>Segments</h2>
  <p>
    Custom devices may have one or more segments, which are uncommitted buffers
    of data. Each segment has a name for referencing, a fixed size, and an
    optional initialization pattern:
  </p>
  <pre>  Segment rom: {
      size: 8192,
      source: "cart.bin"
  };

  Segment ram: {
      size: 8192,
      init_pattern: 255
  };

  Segment nvram: {
    size: 256,
    init_pattern: [0, 255],
    persistence: "nonvolatile"
  };
  </pre>
  <p>
    Segments have multiple uses, including backing memory for memory layers,
    loading predefined blobs from files, and writable temporary storage.
    Segments may be any size, including zero bytes, subject to implementation
    limits. Currently, Altirra limits the total size of all segments to 256MB.
  </p>
  <p>
    The member key is the segment name used to reference it from other parts.
    It is case sensitive and must conform to the naming conventions of the
    scripting engine.
  </p>
  <h3>Initialization data</h3>
  <p>
    The segment may be initialized with either source data or an initialization
    pattern. For source data, the source is a filename in the same location as
    the .atconfig file. Only a filename is allowed, no relative or absolute
    paths allowed. Altirra does support ATVFS paths for this, which allows the
    source to be zipped or gzipped (gz://file.bin or zip://file.zip/subfile.bin).
  </p>
  <p>
    For initialization data, the init data is a blob as specified earlier. The
    init data may be from 1-N bytes where N is the size of the segment. If the
    init data is shorter than the segment, it is repeated as needed to fill the
    segment.
  </p>
  <p>
    If no source or initialization data is given, the segment memory is zeroed.
  </p>
  <h3>Persistence</h3>
  <p>
    By default, segments that are not backed by data are volatile and will be
    automatically reinitialized on cold reset. This can be overridden with the
    "persistence" property:
  </p>
  <dl>
    <dt>volatile (default)</dt>
    <dd>
      The segment is reset to its initialization state on
      cold reset. This has no effect on segments that are backed by file.
    </dd>

    <dt>nonvolatile</dt>
    <dd>
      Auto-reinitialization on cold reset is disabled. This is
      useful for segments that are preinitialized by an init script.
    </dd>
  </dl>

  <h2>Memory layers</h2>
  <p>
    Memory layers allow the custom device to interact with the emulated CPU
    using memory mapped I/O. A memory layer is a contiguous memory address range,
    enabled for some or all types of accesses. More precisely:
  </p>
  <ul>
    <li>
      The address range of a memory layer is contiguous and page aligned, within
      the 64K address space.
    </li>
    <li>
      A memory layer may be enabled or disabled independently for both reads and
      writes. ANTIC and CPU reads are handled identically.
    </li>
    <li>
      Memory layers have a defined priority relative to other memory layers.
      A higher priority memory layer can intercept accesses and prevent them
      from being seen by lower layers. Currently, this is fixed at cartridge
      priority (see the output of the .map debugger command).
    </li>
    <li>
      Memory layers can either be directly mapped to a segment or bound to
      a set of address bindings. Direct segment mapping is faster and preferred
      when possible, but requires that the memory layer be a solid mapping.
    </li>
  </ul>
  <pre><![CDATA[
  MemoryLayer wina: {
    name: <Debugger readable name>,
    address: <Starting address of memory layer, page-aligned>,
    size: <Length of memory layer, in bytes>,

    // for layers with a direct segment mapping
    segment: { ... },

    // for dynamically controlled memory layers
    control: { ... },

    // for cartridge-enabled layers (optional)
    cart_mode: ...
  };]]></pre>
  <p>
    A memory layer must either be "segment" or "control" type, but not both.
  </p>
  <h3>Direct mapped layers</h3>
  <p>
    A <i>direct mapped layer</i> is a layer that is directly mapped to segment
    memory. Layers with a direct segment mapping have the following members:
  </p>
  <pre><![CDATA[  segment: {
    source: <segment-variable>,
    offset: <byte offset from start of segment>,
    mode: "r|ro|w|rw"
  }]]></pre>

  <p>
    source (required): The name of the segment to use. Note that this is a
    direct variable reference and not a string, so it isn't quoted.
  </p>
  <p>
    offset (required): The byte offset from the start of the segment to map.
    The mapped range must be page-aligned and be contained entirely within
    the source segment. It is allowed to map part of a segment but the memory
    layer may not extend beyond the end of the segment.
  </p>
  <p>
    mode (required): The memory access mode for the layer. "r" and "w" mean
    reads and writes, respectively. A "r" mode mapping will handle reads but
    allow writes to pass through to lower priority layers; an "rw" mapping will
    handle both reads and writes. An "ro" mode layer is read-only and will block
    writes to lower layers without modifying the mapped segment.
  </p>
  <p>
    Mapping overlapping segment ranges in more than one memory layer
    simultaneously is supported. In this case, reads to the layers return the
    same data and writes to any of the layers are reflected in the other layers.
    This is used to implement address mirroring or dual banking windows.
  </p>
  <p>
    A direct mapping does NOT require that the memory layer always map to a fixed
    location in the segment. The memory layer cannot be changed to binding-based
    mappings on the fly, but it can be revectored to different offsets or
    segments under script control.
  </p>

  <h3>Binding-controlled layers</h3>
  <p>
    A layer with a "control" member is a binding-controlled layer. Each binding
    determines the response for a unique address range and access type in the
    memory layer. This allows behavior specification down to byte granularity.
  </p>
  <p>
    The value of the control member is an array of objects:
  </p>
<pre><![CDATA[  [
    {
      address: <starting address>,
      size: <optional size in bytes>,
      mode: "r|w|rw",

      // one of "data", "action", or "script" required
      data: <data-blob>,
      action: "block|network",
      script: "...",
      debug_script: "..."
    }
  ]]]></pre>
  <p>
    address (required): The absolute starting address of the binding. This must
    be within the address range of the layer.
  </p>
  <p>
    size (optional): The size of the binding in bytes. Must be non-zero and
    the entire binding must fit within the layer. If omitted, the binding is one
    byte in size.
  </p>
  <p>
    mode (required): Whether the binding applies only to read accesses ("r"),
    write accesses ("w"), or both read and write accesses ("rw"). Both the layer
    and binding modes apply and the effective mode is the intersection of the
    two, i.e. an "rw" binding will not respond to writes in an "r" or "ro" mode
    layer.
  </p>
  <p>
    All bindings must have a unique address range and mode. They can overlap in
    addresses for different modes, i.e. $4000/r and $4000/w. It is OK for some
    addresses to not be covered by a binding, in which case they are pass-through
    to lower layers.
  </p>
  <p>
    The response of a binding to a matching access is specified by one of the
    following members:
  </p>
  <dl>
    <dt>"data"</dt>
    <dd>
      Return the given constant blob data. The blob data must either one
      byte to repeat for the entire address range of the binding, or a blob the
      same size as the binding. Data responses are only valid for read bindings.
    </dd>
    <dt>"action"</dt>
    <dd>
      Specifies a special action:

      <dl>
        <dt>"block"</dt>
        <dd>
          Prevent lower layers from seeing the access. This is only valid
          for write bindings.
        </dd>

        <dt>"network"</dt>
        <dd>
          Send the access to the remote server.
        </dd>
      </dl>
    </dd>

    <dt>"script"</dt>
    <dd>
      Specifies a script to run on the read or write access. For write
      bindings, no return value is needed. For read or read/write bindings, the
      byte result of the read access must be returned. The result does not need
      to be restricted to 0-255; for convenience, the lowest 8 bits are used and
      any higher bits are ignored.
    </dd>

    <dt>"debug_script"</dt>
    <dd>
      For read or read/write bindings using the script method,
      a debug script can also be supplied to handle debug reads differently by
      suppressing side effects. This avoids altering machine state when the
      debugger inspects memory. For instance, an address that would normally
      trigger a bank switch on a read should have a debug read override to
      prevent the bank switch.
    </dd>
    <dd>
      If <tt>debug_script</tt> is not specified, the same <tt>script</tt> is used for
      both debug and non-debug reads. The <tt>[debug]</tt> and <tt>[!debug]</tt>
      attributes can be used to conditionally compile statements for only one of
      the modes. See Conditional Compilation in the scripting section for details.
    </dd>

    <dt>"variable"</dt>
    <dd>
      Read or write the named variable: <tt>"variable": "r0"</tt> causes the variable
      <tt>r0</tt> to be read or written on accesses to the given address.
    </dd>
    <dd>
      If the value of the variable exceeds the range of a byte (0-255), the lowest 8 bits
      are taken on a read access.
    </dd>

    <dt>"copy_from"</dt>
    <dd>
      "copy_from": Copies bindings from another address in the same layer. The
      value is the starting address to copy from. For instance, given a layer at
      $D500-D5FF, <tt>"address": "$D580", "mode": "r", "copy_from": "$D500"</tt>
      will copy bindings from $D500-D57F to $D580-D5FF.
    </dd>
    <dd>
      The source bindings must be declared before the copy_from entry. The copy
      is always ascending so that a pattern can be repeated:
    <pre>{ address: $D500, mode: "rw", variable: "r0" },
{ address: $D501, mode: "rw", variable: "r1" },
{ address: $D502, mode: "rw", variable: "r2" },
{ address: $D503, mode: "r", variable: "status" },
{ address: $D504, size: 252, mode: "rw", copy_from: $D500 }
    </pre>
      This copies $D500-D503 to $D504-D5FF, which causes the first four entries
      to be repeated.
    </dd>
  </dl>

  <h3>Cartridge-enabled layers</h3>
  <p>
    The cart_mode member specifies that a memory layer is intended for a
    cartridge and should be connected to the emulator's cartridge logic:
  </p>
  <ul>
    <li>
      Memory layers assigned to the left cartridge slot automatically assert
      the RD5 signal when active. This affects the TRIG3 input on XL/XE
      computers that indicate the presence of a cartridge, as well as
      cartridge sensing for pass-through cartridge ports.
    </li>
    <li>
      Pass-through cartridge ports can disable cartridge-enabled memory layers.
      This happens independently of the mapping mode of the layer.
    </li>
  </ul>
  <p>
    Both direct-mapped and binding-controlled layers can be cartridge-enabled.
  </p>
  <p>
    There are three cartridge enable modes available:
  </p>
  <dl>
    <dt>cart_mode: "left"</dt>
    <dd>
      Hook the layer into the S5-to-RD5 signal chain for the $A000-BFFF address
      range (left cartridge region).
    </dd>

    <dt>cart_mode: "right"</dt>
    <dd>
      Hook the layer into the S4-to-RD4 signal chain for the $8000-9FFF address
      range (right cartridge region).
    </dd>

    <dt>cart_mode: "cctl"</dt>
    <dd>
      Hook the layer into the CCTL signal for the $D500-D5FF cartridge control region.
    </dd>

    <dt>cart_mode: "auto"</dt>
    <dd>
      Select left, right, or cctl modes based on the address range of the memory layer.
    </dd>
  </dl>
  <p>
    Cartridge-enabled layers are not restricted to cartridge ranges and can
    map ranges outside of the normal cartridge address spaces ($8000-BFFF and
    $D500-D5FF).
  </p>
  
  <h3>PBI-enabled layers</h3>
  <p>
    A memory layer marked as <tt>"auto_pbi": true</tt> is automatically enabled only when
    the PBI device is selected. It can only be used when <tt>pbi_device</tt> is declared
    in the device specification.
  </p>

  <h3>Hardware address ranges</h3>
  <p>
    The hardware address range of <tt>$D000-D7FF</tt> contains many address ranges dedicated
    to motherboard resources. This includes GTIA in page $D0, POKEY in page $D2, and
    ANTIC in page $D4. Currently, these cannot be overlaid by custom device memory layers.
    Pages $D1 and $D5-D7 can be overlaid, with the except of the single address $D1FF being
    intercepted if PBI devices are present.
  </p>
  <p>
    The presence of memory layers in the $D1 and $D5-D7 pages will also affect the emulator's
    ability to allocate those pages for high-level emulation hooks, particularly CIO devices
    like the <tt>H:</tt> device. The custom device code will automatically advertise any memory
    layers overlapping these regions so that the hook page can relocated to avoid them.
    This happens whether or not the layers are enabled, as the layer modes can be changed
    on the fly.
  </p>

  <h2>Serial I/O (SIO) devices</h2>
  <p>
    Custom devices can also connect to the serial I/O bus to emulate SIO peripherals.
    This is done in cooperation with the central SIO management code, allowing
    custom peripherals to benefit from common logging and acceleration code that
    is also used by the internal device emulators.
  </p>
  <h3>Declaring SIO devices</h3>
  <p>
    SIO devices are declared as objects of type <tt>SIODevice</tt>:
  </p>
  <pre>  SIODevice disk_device: {
      device_id: $31,
      commands: ...
  };

  SIODevice printer_device: {
      device_id: $40,
      device_count: 4,
      commands: ...
  };</pre>
  <p>
    <tt>device_id</tt> indicates the device ID as seen on the SIO bus. <tt>device_count</tt>,
    if present, specifies that more than one device ID should be handled, starting at the given
    device ID. This is used to claim a range of device IDs without having to repeat the command
    definitions.
  </p>
  <p>
    The custom device will only respond to commands for the given device IDs. Commands for other
    device IDs are ignored and not seen by the custom device. It is assumed that all of the
    device IDs are being implemented by a single physical device that can only handle one command
    at a time, so it is not possible for the custom device to handle simultaneous commands to
    different devices or the same device.
  </p>
  <h3>Declaring SIO commands</h3>
  <p>
    The <tt>commands</tt> member of a device declaration contains the list of commands supported
    by that device. It is an array of objects, one for each command:
  </p>
  <pre>
    commands: [
      { id: $48 },
      {
        id: $53,
        auto_transfer: { mode: "read", segment: "status", offset: 0, length: 4 }
      },
      {
          id: $50,
          script: function {
              $sio.ack();
              $sio.recv_frame(128);
              disk.copy(($aux - 1)*128, $sio_frame, 0, 128);
              $sio.complete();
          }
      },
      { id: $57, copy_from: $50 }
    ]
  </pre>
  <p>
    The <tt>id</tt> member is required and specifies the command ID for the command, as specified
    by the second byte in the SIO command frame. All commands within a device must have unique IDs.
    This can also be the special name <tt>default</tt>, which means all commands not already implemented.
  </p>
  <p>
    A command with only <tt>id</tt> simply returns ACK and then Complete, implementing a no-op command
    that completes successfully without doing anything.
  </p>
  <p>
    A command with <tt>auto_transfer</tt> implements a command that automatically issues a read transfer
    from a segment or a write transfer to a segment. The <tt>mode</tt> member specifies the transfer
    direction, from the standpoint of the computer. A <tt>read</tt> command allows the computer to read
    from a device segment, while <tt>write</tt> has the computer writing to a device segment. <tt>segment</tt>
    specifies the segment name, while <tt>offset</tt> and <tt>length</tt> specify the starting offset
    in the segment and the transfer length. The transfer range must fit within the segment.
  </p>
  <p>
    <tt>script</tt> is the most flexible option as it runs a script to drive the SIO transaction. The
    script has access to the SIO command frame and can send command status bytes as well as sending or
    receiving data frames. It can also inject delays.
  </p>
  <p>
    Finally, a <tt>copy_from</tt> command copies a command definition to another command ID, reusing it.
    The value is the command ID to copy from, which must have been declared earlier. One use for this is
    to reuse the same commmand definition for the Put and Write commands of a disk drive.
  </p>

  <h3>SIO protocol handling</h3>
  <p>
    The command frame is automatically validated prior to dispatching to the command handlers. A command
    frame target at a device ID not declared in the custom device is ignored. Command frames with
    a matching device but a non-matching command are NAKed. Command frames with invalid checksums are
    ignored.
  </p>
  <p>
    For non-script commands, the entire protocol is handled by the host. For scripted commands, the
    script begins execution after the command line is deasserted and is responsible for everything
    including sending the initial ACK/NAK for the command. This is done through the <tt>$sio</tt>
    object, which has methods for all remaining bus transactions needed.
  </p>
  <p>
    The high-level flow that scripts need to implement for standard SIO transactions is as follows:
  </p>
  <ul class="spaced">
    <li>
      Check if the command is valid. If it is not, send a NAK (<tt>$sio.nak()</tt>) and end command processing. An example
      of a condition that should cause a command NAK is a Read Sector command to a disk drive with
      an invalid sector number. Checks done here can generally only depend upon immediate device and command state since
      the ACK/NAK must be sent in 16ms; a disk drive could not read or write sectors before sending the command ACK/NAK,
      for instance.
    </li>
    <li>
      ACK the command (<tt>$sio.ack()</tt>).
    </li>
    <li>
      If the command is a write command, where the computer writes data to the device:
    </li>
    <ul>
      <li>Receive the data frame from the computer (<tt>$sio.recv_frame()</tt>).</li>
      <li>[The host will automatically NAK the data frame and end the script here if a checksum error occurs.]</li>
      <li>ACK the data frame (<tt>$sio.ack()</tt>).</li>
      <li>Process the data frame.</li>
    </ul>
    <li>
      Send Complete (<tt>$sio.complete()</tt>) or Error (<tt>$sio.error()</tt>) depending on whether
      the operation completes successfully. Note that command processing does <b>not</b> stop here
      on Error, since a data frame still needs to be sent even if it has no useful data in it.
    </li>
    <li>
      If the command is a read command, where the computer reads data from the device:
    </li>
    <ul>
      <li>Send the data frame to the computer (<tt>$sio.send_frame()</tt>).</li>
    </ul>
  </ul>
  <p>
    The current command is automatically aborted by the host if the SIO command line is asserted before
    the command completes or a reset event occurs.
  </p>

  <h3>Protocol timing</h3>
  <p>
    The SIO protocol has minimum and maximum timing requirements between phases of bus transactions.
    These are mainly related to periods where either the computer or the peripheral need to reconfigure
    its serial interface between sending and receiving data. Violating minimum bounds can cause lost
    or corrupted data bytes, while violating maximum bounds results in timeouts.
  </p>
  <p>
    When implementing a custom device, all timings are in emulation time, where time only passes when
    the script deliberately executes a delay or sends or receives bytes. All other actions, such as
    executing a script or performing a network transaction take zero emulation time since the 6502 does
    not run. Making a network call that takes too long will slow down the emulator but not change the
    timing relationship between the 6502, the chipset, and the device. Thus, in general, there are no
    problems with the custom device being too slow to respond.
  </p>
  <p>
    Where problems <i>can</i> occur is with the custom device being too fast in emulation time, violating
    minimum bounds because it can do all processing in zero time.
    To prevent this, the custom device host automatically inserts delays into specific parts of the
    transaction:
  </p>
  <ul>
    <li>The command handler starts running after the command line is deasserted, so the script can send the command frame ACK/NAK immediately.</li>
    <li>A delay of 850 &#181;s is inserted before the ACK/NAK of a received data frame.</li>
    <li>A delay of 250 &#181;s is inserted before Error/Complete bytes.</li>
  </ul>
  <p>
    Therefore, no explicit delays are needed in a script to meet minimum timing requirements. A script
    may freely call <tt>ack()</tt>, <tt>complete()</tt>, and <tt>send_frame()</tt> back-to-back and
    the custom device engine will ensure that the minimum protocol delays are observed.
  </p>

  <h3>Using sent/received data</h3>
  <p>
    Typically a custom SIO device will use additional segments to handle data
    transfers, such as a disk image segment or a status frame segment. These segments
    should be marked with <tt>nonvolatile</tt> persistence so that they are not reset
    when the peripheral is power-cycled. This is only needed if they are not file-sourced,
    however, as those are implicitly nonvolatile.
  </p>
  <p>
    Canned replies, such as Status requests from some devices, can put the predefined
    reply into a segment with an <tt>init_pattern</tt> and use the <tt>auto_transfer</tt> mode, allowing the host to
    drive the entire SIO protocol. Otherwise, the <tt>Segment.copy()</tt> method is
    useful in SIO command scripts, particularly in write commands to copy from the
    <tt>$sioframe</tt> receive segment to a work segment. This is less needed for
    read commands, which can <tt>send_frame()</tt> directly from segments.
  </p>


  <h3>Concurrency with other scripts</h3>
  <p>
    Because SIO command scripts can be suspended by a send/receive operation or an explicit delay,
    they can run in parallel with other scripts in the custom device, most notably memory access handlers.
    Only one script can execute at a time, so the scripts can only switch off at suspension points -- there
    is no risk of data races as in a multi-core CPU. However, global state variables may change if shared
    between the scripts.
  </p>
  <p>
    Some special variables are instanced per thread and not shared. In particular, the <tt>$timestamp</tt>
    variable is thread-local. In an SIO script, it always gives the timestamp of the start of script
    execution regardless of suspend points within the script. Any other scripts that execute during the
    command receive their own <tt>$timestamp</tt> values.
  </p>


  <h3>Accelerated transfers</h3>
  <p>
    Two types of acceleration can be implemented by the host, burst I/O transfers and HLE accelerated transfers.
    Both are handled automatically and do not require handling by script. Acceleration support is controlled
    by device ID, so enabling D: acceleration will affect both internal and custom devices that use $31-3F
    device IDs.
  </p>
  <p>
    In a burst I/O transfer, handshaking is implemented between POKEY and the device so that the time
    between serial input ready interrupts is shortened, depending on how fast the 6502 can acknowledge it.
    This results in the effective transfer rate rising above 19,200 baud adaptively to as fast as the serial
    IRQ handler can handle. For a custom device, this results in <tt>recv_frame()</tt> operations occurring
    more quickly than normal.
  </p>
  <p>
    HLE acceleration uses CPU interception instead and transfers data directly between memory and the device.
    When this occurs, SIO operations are short-circuited and occur in zero time. All delays are skipped,
    ACK/NAK/Complete/Error bytes are handled directly, and serial transfers occur immediately via DMA.
    The HLE code does some checks for whether accelerating the transfer is safe and will skip doing so in
    some cases, such as if it cannot verify that the OS SIO routines are being used or the transfer overlaps
    OS variables that would be used in the transfer. It also assumes that the device implementation conforms
    to the standard SIO protocol and that at most one read or write data frame transfer takes place, which
    is compared against the DCB parameters to determine the resulting status and buffer contents.
  </p>
  <p>
    HLE acceleration can be disabled on either a device or command basis by specifying <tt>"allow_accel": false</tt>
    in the device or command object.
  </p>
  
  <h3>Raw SIO transfers</h3>
  <p>
    For the lowest level of SIO device emulation, a custom device can bypass the SIO manager and use raw SIO
    to directly send and receive bytes on the SIO bus. This allows full control over transfer format and
    timing and permits emulation of SIO devices that do not use standard SIO command frames, such as
    serial port devices.
  </p>
  <p>
    To use raw SIO, one or more script threads must be set up to handle transfers on the SIO bus and raw
    SIO must then be enabled. This can be done either autonomously or triggered from an SIO command, depending
    on the requirements of the custom device. However, in the latter case, the SIO command script itself
    cannot drive the raw SIO transaction -- it must hand off to a worker thread to do so:
  </p>
  <pre><![CDATA[  Thread rawsio_thread;

  void handle_raw_transfer() {
    $sio.enable_raw(true);

    $sio.send_raw_byte($00, 94);
    Thread.sleep(100);
    $sio.send_raw_byte($01, 94);
    $sio.send_raw_byte($02, 94);
    int data = $sio.recv_raw_byte();

    $sio.enable_raw(false);
  }

  void handle_command() {
    $sio.ack();
    $sio.complete();
    rawsio_thread.run(handle_raw_transfer);
  }]]></pre>
  <p>
    A single thread can be used for both sending and receiving or two threads can handle the two directions
    independently, depending on whether the emulated device uses half-duplex or full-duplex communication.
    A disk drive can use one thread since its controller typically can only handle half-duplex, whereas a serial
    device would use two threads for full-duplex operation.
  </p>
  <p>
    The <tt>SIO</tt> class provides some assistance for common SIO emulation patterns. Wait functions are
    provided to efficiently wait for transitions on the SIO command line, to synchronize phases of the SIO
    command protocol or allow a monitoring thread to efficiently interrupt serial transfer. Checksums are
    also automatically computed for bytes sent and received by script, avoiding the need to manually re-compute
    the checksums for verification.
  </p>
  <p>
    When raw SIO is active, all standard SIO command processing for the custom device is suspended. If standard
    SIO command processing is desired, raw SIO must be cancelled prior to the trailing (deasserting) edge of
    the SIO command line for the custom device's SIO command tables to be re-enabled. However, all other devices
    in the system will still monitor for standard SIO commands regardless of the custom device's raw SIO state,
    as occurs in an actual SIO device chain on real hardware.
  </p>

  <h3>Conflicts with built-in devices</h3>
  <p>
    A custom device may not work correctly if it attempts to implement an SIO device that is also
    being handled by an active internal device in the emulator. This is the emulation equivalent of a bus
    fight. In these cases, the internal device must be disabled for the custom device to work.
  </p>
  <p>
    In Altirra, the most likely conflict of this type is with the disk emulator. To turn off the built-in
    emulation, the disk drive must be changed to Off in Disk Drives. This can be done either through the
    drop-down or by clicking the Eject button twice.
  </p>


  <h2>Parallel Bus Interface (PBI)</h2>
  <p>
    A <tt>pbi_device</tt> section enables Parallel Bus Interface (PBI) support. It has one member,
    the <tt>device_id</tt> for the PBI device:
  </p>
  <pre>  PBIDevice pbi_device: {
      device_id: $40
  };</pre>
  <p>
    Exactly one bit must be set in the device ID, with $01..$80 corresponding to PBI devices 0-7.
    Only one <tt>PBIDevice</tt> object can be defined.
    For the purposes of the custom device, the XE Enhanced Cartridge Interface (ECI) is considered
    as equivalent to the PBI.
  </p>
  <p>
    When enabled, Altirra's built-in PBI disk acceleration hardware uses PBI device 7 (ID $80).
    The Atari OS scans enabled PBI devices from device 0 to 7 ($01 to $80), so ID $01 has the highest
    priority. SpartaDOS X, however, scans PBI devices in reverse order and thus priority.
  </p>
  <h3>Selection support</h3>
  <p>
    When PBI device support is enabled, the host automatically monitors writes to the <tt>$D1FF</tt>
    PBI device selection address and will enable the custom PBI device when the specified device ID
    bit is set. This avoids the need to manually map memory layer over the <tt>$D1xx</tt> page with
    a write mapping over that address and allows it to be multiplexed between multiple PBI devices on
    different IDs. The <tt>pbi_select</tt> and <tt>pbi_deselect</tt> script events
    are dispatched when the PBI device is selected or deselected, allowing script to respond to device
    selection. The host will also automatically deselect any active PBI device when a computer reset
    occurs.
  </p>
  <h3>Auto-PBI memory layers</h3>
  <p>
    Memory layers set to <tt>"auto_pbi": true</tt> are enabled for PBI support: their
    priority in the MMU is raised so they can properly overlay motherboard memory resources and the
    math pack ROM, and they are automatically enabled and disabled when the device is selected or
    deselected. Thus, simple PBI devices can switch in both a firmware ROM over the math pack at
    <tt>$D800-DFFF</tt> and control registers without requiring explicit script actions.
  </p>
  <p>
    Additionally, any auto-PBI layer mapped to within <tt>$D800-DFFF</tt> also automatically disables
    emulation hooks in the math pack ROM when it is active so that they do not interfere with PBI firmware.
  </p>

  <h2>Controller ports</h2>
  <p>
    Controller ports are bound by creating objects of type <tt>ControllerPort</tt>:
  </p>
  <pre>  ControllerPort port1: 0;
  ControllerPort port2: 1;</pre>
  <p>
    Each member is the variable name to bind the controller port and the index (0-3). The variable then
    points to an object of type <tt>ControllerPort</tt>, which can be manipulated through script.
  </p>
  <p>
    On XL/XE machines, ports 3 and 4 can be bound but are inactive. Their state is preserved and will
    become active if the machine type is switched to 400/800.
  </p>


  <h2>Scripting</h2>
  <p>
    Custom device behaviors are driven through scripts. These are small fragments
    of code that can maintain state in the custom device and alter its behavior,
    such as by altering memory layers. The scripts are written in a C-like
    language and compiled to bytecode. Thus, they are a bit slower than native
    code, but much faster than using the network server.
  </p>
  <p>
    Example:
  </p>
  <pre><![CDATA[
    if (bank_a != $value) {
        bank_a = $value;

        window_a.set_offset(bank_a << 14);
    }
  ]]></pre>

  <h3>Global variables</h3>
  <p>
    As noted earlier, global variables are declared at top-level scope with type followed by
    variable name: 
  </p>
  <pre>  int r0;</pre>
  <p>
    Variables of type <tt>int</tt> are read/write and can be changed by script. They always default
    to zero when the device is created, but are <i>not</i> automatically cleared afterward; script
    must explicitly reset their values if desired on a cold reset.
  </p>
  <p>
    Object variables, such as ones of type <tt>SIODevice</tt> or <tt>Thread</tt>, are read-only and
    are permanently bound to a unique object instance on creation. They cannot be reassigned to
    point to a different object instance, and are never null.
  </p>

  <h3>Special variables</h3>
  <p>
    Variables prefixed with <tt>$</tt> are special read-only variables provided
    by the host, containing special values of use to the script related to the
    emulated computer or the request that the script is being run for.
  </p>
  <dl>
    <dt>$address</dt>
    <dd>
      Contains the access memory address or memory read or write scripts.
    </dd>

    <dt>$value</dt>
    <dd>
      Contains the byte value being written for memory write scripts.
    </dd>

    <dt>$timestamp</dt>
    <dd>
      Contains the current machine clock cycle, counting up at 1.77/1.79MHz. The
      absolute value of this counter has no meaning, only differences between values.
      This measures emulation time, which measures clock cycles run by the CPU or
      chipset logic; it diverges from real-time whenever the emulator is paused or
      running in turbo mode.
    </dd>
    <dd>
      Emulation time is monotonic and counts forward even if a save state is loaded or
      a reset occurs. However, because the timestamp variable is 32-bit, it is negative half the time and wraps
      every 40 minutes of emulated time. Timestamp calculations must take wrapping into
      account. For instance, <tt>$timestamp &gt; last_time</tt> is unsafe and should
      be replaced with <tt>$timestamp - last_time &gt; 0</tt>. The emulator deliberately
      starts the timestamp counter at a value other than 0 to expose timestamp handling issues.
    </dd>

    <dt>$device</dt>
    <dd>
      For an SIO command handler, contains the device ID of the SIO command (first byte).
    </dd>

    <dt>$command</dt>
    <dd>
      For an SIO command handler, contains the command ID of the SIO command (second byte).
    </dd>

    <dt>$aux1</dt>
    <dd>
      For an SIO command handler, contains the first argument byte of the SIO command (third byte).
    </dd>

    <dt>$aux2</dt>
    <dd>
      For an SIO command handler, contains the second argument byte of the SIO command (fourth byte).
    </dd>

    <dt>$aux</dt>
    <dd>
      For an SIO command handler, contains the argument bytes of the SIO command combined into a single 16-bit
      value. This is equivalent to <tt>$aux1 + 256*$aux2</tt>.
    </dd>
  </dl>

  <h3>Local variables</h3>
  <p>
    A variable declaration inside of a function or script is a local variable, which exists only during
    execution of that function or script. It is declared the same way as a variable, with the type followed
    by one or more variable names:
  </p>
  <pre>  int local_var1, local_var2;</pre>
  <p>
    Local variables must be defined before they are used, and are only valid within the scope in which they
    are defined:
  </p>
  <pre>  {
    int x;

    x = 1;

    {
      int y;
      y = 2;
    }

    y = 3;    // error, y not defined in this scope
  }</pre>
  <p>
    To ensure consistent behavior, local variables are always initialized to zero at the beginning of the
    function. This ensures that random data is never used. However, it does not guarantee that the variable
    is zero when declared within a loop, so relying on the initial value of a variable is not recommended.
  </p>
  <p>
    Each invocation of a script function has a unique set of local variables. This is true either in the case
    of recursion -- a function calling itself either directly or indirectly -- or through execution on multiple
    threads, like a common function used from both an SIO command handler and a memory access handler.
  </p>

  <h3>Expressions</h3>
  <p>
    Expressions are similar to the C language, consisting of the following
    operators, from highest to lowest precedence:
  </p>
  <pre><![CDATA[
   Postfix          .               (dereference)
   Unary            +, -, ~, !      (unary plus/minus, bitwise/logical inversion)
   Multiplicative   *, /, %         (multiply, divide, remainder)
   Additive         +, -            (add, subtract)
   Shift            <<, >>          (arithmetic left/right shift)
   Bitwise AND      &               (bitwise AND)
   Bitwise XOR      ^               (bitwise XOR)
   Bitwise OR       |               (bitwise OR)
   Relational       <, <=, >, >=    (less [equal] and greater [equal])
   Equality         ==, !=          (equal, not equal)
   Logical AND      &&              (short-circuited AND)
   Logical OR       ||              (short-circuited OR)
   Assignment       =               (assignment to variable)
]]></pre>
  <p>
    All operators work with 32-bit signed two's complement integer arithmetic.
    As in C, operations that take boolean inputs treat non-zero values as
    'true' and those that return boolean results give 0 for false and 1 for
    true.
  </p>
  <p>
    The logical AND (<tt>&amp;&amp;</tt>) and logical OR (<tt>||</tt>)
    operators are short-circuiting and will evaluate their right-hand operand
    only if the result is not already determined by the left-hand operand.
    This has functional consequences for a function or method call on the
    right side.
  </p>
  <p>
    There are some differences from C:
  </p>
  <ul>
    <li>
      Hexadecimal numbers are specified with $ instead of 0x prefix.
    </li>
    <li>
      There is no octal.
    </li>
    <li>
      Signed overflow is defined as wrapping in 32-bit.
    </li>
    <li>
      Division/remainder by 0 gives 0, and -$80000000/-1 = -$80000000. No
      exception is raised.
    </li>
    <li>
      The shift operators mask their shift counts by 31.
    </li>
    <li>
      Assignment does not return a value (result is void type).
    </li>
    <li>
      There are no increment/decrement or assignment arithmetic operators.
    </li>
    <li>
      There is no floating point or unsigned math.
    </li>
  </ul>
  <p>
    The keywords 'true' and 'false' are also provided for readability in
    boolean logic. They evaluate to the integers 1 and 0, respectively.
  </p>
  <h3>Statements</h3>
  <p>
    A function body consists of a sequence of statements, which can be one of:
  </p>
  <ul>
    <li>A local variable declaration.</li>
    <li>An expression, which may include an assignment or a method/function call.</li>
    <li>An if statement.</li>
    <li>A return statement.</li>
    <li>A loop statement.</li>
    <li>A block of statements, contained in braces { ... }.</li>
  </ul>
  <p>
    In all cases except for a block, the statement ends in a semicolon.
    Statements may be freely split across lines and indentation is ignored
    by the compiler.
  </p>
  <p>
    Note that a block does not end in a semicolon, and adding one will
    result in a syntax error (doing this results in two statements in C,
    typically with unfortunate consequences).
  </p>
  <h3>Returning values</h3>
  <p>
    Calls to script to request a value, mainly memory read accesses, require
    the script to return a value. This is done with the return statement:
  </p>
  <pre><![CDATA[
  return x + 1;
  return $FF;
]]></pre>
  <p>
    Execution of the function or script ends when the return statement is
    executed and all code after it is skipped.
  </p>
  <p>
    Some scripts are required to return a value, such as those called for
    a memory read access. This is enforced by the compiler, which checks that
    all branch paths through the code end in a return. If one does not, such
    as a return only inside of an if(), the script compiler will throw an error.
  </p>
  <p>
    Scripts that don't need to return a value, such as memory write handlers,
    have "void" return type and don't need a return statement. A return can still
    be used with no argument, however, to end the script early:
  </p>
  <pre>return;</pre>

  <h3>Branching</h3>
  <p>
    The 'if' statement is used to conditionally execute some statements:
  </p>

  <pre><![CDATA[
  if ($timestamp & 1)
    counter = counter + 1;
]]></pre>

  <p>
    The expression after the if keyword is the condition, and the statement
    after the condition is the controlled statement, executed only if the
    condition is non-zero. The controlled statement may be a block, which is
    required if more than one statement is to be controlled:
  </p>

  <pre><![CDATA[
  if ($timestamp & 1) {
    counter = counter + 1;
    counter2 = counter2 + 3;
  }
]]></pre>
  <p>
    An 'else' clause may also be used, which is executed only if the
    condition is false:
  </p>
  <pre><![CDATA[
  if ($timestamp & 1)
    counter = counter + 1;
  else
    counter = counter - 1;
]]></pre>

  <h3>Looping</h3>
  <p>
    The <tt>loop</tt> statement creates an infinite loop, which runs its
    controlled statement over and over:
  </p>
  <pre>  loop {
      Thread.sleep(100);
      counter = counter + 1;
  }</pre>
  <p>
    This is most often used in threads to run a background process. Generally,
    a loop must have a <tt>return</tt> statement or a yielding method call;
    otherwise, the loop would run infinitely without ending or pausing. The
    virtual machine guards against this and will force a script to terminate
    if it takes too long and would hang the emulator.
  </p>

  <h3>Conditional compilation</h3>
  <p>
    In some cases, the same script can be reused for two similar but slightly
    different scenarios. Conditional compilation allows an inline script
    to be specialized for the different scenarios without requiring duplication
    of the script or a costly runtime branch. This is used for memory read
    handlers to allow the same script to handle debug and non-debug reads,
    suppressing side effects for the debug read case.
  </p>
  <p>
    A statement is conditionally compiled by prefixing it with either the
    <tt>[debug]</tt> or <tt>[!debug]</tt> attributes:
  </p>
  <pre>  [!debug] layer.set_modes(0, 0);

  [debug]
  if (condition)
      debug.log("condition false");
  else
      debug.log("condition true");</pre>
  <p>
    The <tt>[debug]</tt> attribute only includes the next statement for a debug read,
    while the <tt>[!debug]</tt> attribute only includes it for a non-debug read. For
    a <tt>loop</tt> statement, this includes the body of the loop, and for an <tt>if</tt>
    statement, this includes the controlled statement along with any associated <tt>else</tt>
    clause. The conditional statement can also be a block:
  </p>
  <pre><![CDATA[  [!debug] {
      wina.set_offset(($address & 7) << 13);
      wina.set_modes(1, 1);
  }]]></pre>
  <p>
    The conditional attribute does not introduce a new scope, so variable declarations
    can be conditionally compiled with the declared variable visible to later code:
  </p>
  <pre>  [!debug] int prev_value = value;

  int v = read_state();

  [!debug]
  if (value != prev_value)
      update();

  return v;</pre>

  <h3>Functions</h3>
  <p>
    Functions can be declared to group common logic for reuse in multiple
    scripts. This must be done from a script include. The syntax is as
    follows:
  </p>
  <pre><![CDATA[
  'function' return-type function-name() {
    ...function-body...
  }
]]></pre>
  <p>
    For example:
  </p>
  <pre><![CDATA[
  function void update_bank() {
    bank = bank + 1;
  }
]]></pre>
  <p>
    Scripts specified in-line in event handlers in the .atdevice file
    are actually just anonymous functions where the function return
    type is implicit and only the function body is given.
  </p>

  <h3>Calling functions</h3>
  <p>
    A function is called by specifying its name, followed by an empty
    set of parentheses after it:
  </p>
  <pre>  update_bank();</pre>
  <p>
    When the function returns a value, it can also be used inside of an
    expression:
  </p>
  <pre>  bank = get_last_bank() + 1;</pre>
  <p>
    Functions can call other functions, but if a recursion loop occurs the function
    call chain will be truncated to prevent a crash.
  </p>

  <h3>Calling methods</h3>
  <p>
    Host-provided objects such as segments and memory layers have <i>methods</i>
    associated with them that can be called to query or modify the object.
    These are called methods instead of functions because they are called in the
    context of an object. The syntax is similar to a function call, except that
    the name is specified after the object with a dot:
  </p>

  <pre><![CDATA[
  object-expr '.' method-name '(' [arg [, arg...]] ')'
]]></pre>

  <p>
    For instance, memory layers have a set_offset() method to change the
    segment offset of a direct-mapped layer. It takes one integer argument,
    the new starting byte offset. Thus, it can be called on a layer object
    called window_a as follows:
  </p>

  <pre><![CDATA[
  window_a.set_offset($4000);
]]></pre>

  <p>
    Some classes also have <i>static methods</i>, which are called wtihin the
    context of the class and don't need an object instance. For these, the
    class name is specified before the dot instead of an object expression:
  </p>
  <pre>  Thread.sleep(100);</pre>

  <h3>Threading</h3>
  <p>
    Script threads can be created to emulate parallel processes. A thread
    is simply declared as a variable of class type <tt>Thread</tt>:
  </p>
  <pre>  Thread cmd_thread, monitor_thread;</pre>
  <p>
    A script thread is used by calling the <tt>run()</tt> method on the thread
    object with the name of a function to run on the thread. This function
    must have a return type of <tt>void</tt> with no arguments. Note that
    no <tt>()</tt> is used after the name of the function, as the function is
    meant to be passed to <tt>run()</tt> instead of being executed immediately.
  </p>
  <pre>  cmd_thread.run(cmd_handler);</pre>
  <p>
    Threads are cooperatively scheduled, meaning that only one thread
    is running at a time until either it completes execution of the top-level
    function that was passed to <tt>run()</tt> or it is suspended in a method
    call. Between those points, script execution on the currently running
    thread is atomic: no other script threads run and no emulation time passes.
    Thus, locking primitives are generally not necessary for shared mutable
    data between threads.
  </p>
  <p>
    Script threads are not OS-level threads and are relatively cheap; creating
    several threads that spend the majority of the time waiting on events is
    fine. Polling with threads in tight <tt>Thread.sleep()</tt> loops, however,
    is very bad for emulator performance and to be avoided, especially since
    script performance is lower than native code. For instance, a clock
    cycle counter is much more efficiently updated at read with <tt>$timestamp</tt>
    than by using a thread to continuously maintain it.
  </p>

  <h3>Scripted events</h3>
  <p>
    Certain global events are exposed by the emulator and can have scripts
    attached to them. These are bound using the <tt>event</tt> statement:
  </p>
  <pre>  event "cold_reset": function {
      bank = 0;
  };</pre>
  <p>
    Supported events are:
  </p>

  <dl>
    <dt>"init"</dt>
    <dd>
      Called once when the device is instantiated, and never again.
      This is used for one-time initialization, like reformatting data from
      disk.
    </dd>

    <dt>"cold_reset"</dt>
    <dd>
      Called on a power-cycle event for the device. This is normally
      where script does its state initialization. Typically all state should be
      reset here except for state that is supposed to be non-volatile, like
      battery backed up memory. Any volatile segments are reinitialized before
      this script is run.
    </dd>

    <dt>"warm_reset"</dt>
    <dd>
      Called on a System Reset of the computer.
    </dd>

    <dt>"vblank"</dt>
    <dd>
      Called every frame at the start of vertical blank at line 248. Note that
      this event is invoked regardless of whether the vertical blank interrupt
      is enabled.
    </dd>

    <dt>"sio_command_changed"</dt>
    <dd>
      Called whenever the state of the SIO command line changes. Note that this
      is only called when raw SIO is enabled.
    </dd>

    <dt>"sio_motor_changed"</dt>
    <dd>
      Called whenever the state of the SIO motor line changes. Note that this
      is only called when raw SIO is enabled.
    </dd>

    <dt>"sio_received_byte"</dt>
    <dd>
      Called whenever a byte is sent on the SIO bus in with raw SIO enabled.
      This hook has priority over <tt>recv_raw_byte()</tt> calls; the two should
      not be used together.
    </dd>

    <dt>"pbi_select"</dt>
    <dd>
      Called when the declared PBI device is selected.
    </dd>

    <dt>"pbi_deselect"</dt>
    <dd>
      Called when the declared PBI device is deselected.
    </dd>

    <dt>"network_interrupt"</dt>
    <dd>
      Called when a network server sends an interrupt request.
    </dd>
  </dl>

  <h2>Scripting method reference</h2>
  <p>
    All methods are described in terms of C prototypes for recognizability, even
    though the scripting language does not use such syntax. Argument types should
    be omitted and the names do not have to be used. For instance, for a method
    with the following prototype:
  </p>
  <pre>  void copy_from(int offset, Segment *arg2);</pre>
  <p>
    It could be called as follows:
  </p>
  <pre>  segment1.copy_from(0, segment2);</pre>
  <p>
    A <tt>static</tt> method is one that is called with the class name instead of
    an object instance:
  </p>
  <pre>  Thread.sleep(100);</pre>

  <h3>Segments</h3>
  <dl class="scripting-ref">
    <dt>void clear(int value);</dt>
    <dd>
      Clears the entire segment segment with the given byte value.
    </dd>

    <dt>void fill(int offset, int value, int size);</dt>
    <dd>
      Fills a portion of a segment with the given starting byte offset, byte
      value, and number of bytes to fill. The range to fill must be fully
      contained within the segment.
    </dd>

    <dt>void copy(int dest_offset, Segment *src_segment, int src_offset, int size);</dt>
    <dd>
      Copies a range from a source segment to this segment, given starting
      byte offsets in both segments and the number of bytes to copy. The
      source and destination ranges must be fully contained within the
      respective segments. size=0 is silently ignored.
    </dd>
    <dd>
      The source and destination segments can be the same. If the copy ranges
      overlap, the copy direction is selected to preserve the contents of the
      copied range at the new location (memmove semantics).
    </dd>
    <dd>
      Copying large amounts of data with copy() is slow and should not be used
      to implement memory banking. Changing the offset of a memory layer is
      faster.
    </dd>

    <dt>int read_byte(int offset);</dt>
    <dd>
      Reads the byte at the given offset within the segment, as value 0-255.
      The offset must be within the segment.
    </dd>

    <dt>void write_byte(int offset, int value);</dt>
    <dd>
      Writes a byte value at the given offset within the segment. The byte
      value to be written is 0-255, but other values may be given, in which
      case the lowest 8 bits are used.
    </dd>
  </dl>

  <h3>Memory layers</h3>
  <dl class="scripting-ref">
    <dt>void set_offset(int offset);</dt>
    <dd>
      Sets the starting byte offset of a direct-mapped layer within its mapped
      segment. For instance, a value of $2000 for a layer size of $1000 will map
      $2000-3FFF, which requires that the mapped segment be at least $4000 bytes.
      Attempting to call this for a binding-controlled segment or with an invalid
      offset is an error.
    </dd>

    <dt>void set_segment_and_offset(Segment *seg, int offset);</dt>
    <dd>
      Sets both the mapped segment and offset within that segment used by
      a direct-mapped memory layer. The offset must satisfy the requirements
      of <tt>set_offset()</tt> for the new segment.
    </dd>

    <dt>void set_modes(int read_enable, int write_enable);</dt>
    <dd>
      Enables or disables the layer for read or write accesses. For a read-only
      layer, the write enable controls whether the layer blocks write accesses
      to lower layers; it will not enable write accesses into the layer itself.
    </dd>
    <dd>
      For cartridge-enabled or auto-PBI layers, <tt>set_modes()</tt> will not
      enable a layer when the cartridge is disabled or PBI device is deselected.
      However, the desired mode is still changed and will become active when the
      cartridge or PBI device is enabled.
    </dd>

    <dt>void set_read_only(int enabled);</dt>
    <dd>
      Sets or clears the read-only state for a memory layer. A memory layer
      that is read-only and mapped for write access will intercept writes
      from lower memory layers but not change the contents of the backing
      segment. The read-only state has no effect if the memory layer is not
      mapped for write.
    </dd>
  </dl>

  <h3>Network connection</h3>
  <p>
    The network connection is accessed through the <tt>$network</tt> object.
  </p>
  <dl class="scripting-ref">
    <dt>int send_message(int param1, int param2);</dt>
    <dd>
      Sends a message to the network server and waits for an integer response,
      servicing requests from the server during the transaction. The meaning
      of the two parameters and the return value are user-defined and up to
      the server implementation.
    </dd>

    <dt>void post_message(int param1, int param2);</dt>
    <dd>
      Posts a message to the network server without waiting for a response.
      The meaning of the two parameters and the return value are user-defined
      and up to the server implementation.
    </dd>
    <dd>
      This is faster than <tt>send_message</tt> because it does not require
      the emulator to wait for the server.
    </dd>
  </dl>

  <h3>SIO connection</h3>
  <p>
    The serial I/O (SIO) bus is accessed through the <tt>$sio</tt> object.
    The methods on this object are only valid in scripts that are processing
    SIO requests.
  </p>
  <p>
    For methods in this class, "send" and "receive" are from the standpoint
    of the device. A send operation transmits data from the device to the computer,
    and a receive operation transmits data from the computer to the device.
  </p>
  <dl class="scripting-ref">
    <dt>void ack();</dt>
    <dd>
      Send an ACK byte ($41) to the computer. This is used to affirm reception
      of a valid command or data frame.
    </dd>
    <dd>
      There is a built-in delay of 850 &#181;s before the A byte when an ACK is
      sent after a received data frame to ensure that SIO protocol requirements
      are met and the OS can receive the byte properly.
    </dd>

    <dt>void nak();</dt>
    <dd>
      Send an NAK byte ($4E) to the computer. This is used to signal an invalid
      command or a corrupted data frame.
    </dd>
    <dd>
      There is a built-in delay of 850 &#181;s before the N byte when an ACK is
      sent after a received data frame to ensure that SIO protocol requirements
      are met and the OS can receive the byte properly.
    </dd>

    <dt>void error();</dt>
    <dd>
      Send an Error byte ($45) to the computer. This is used to signal completion
      of a failed command.
    </dd>
    <dd>
      There is a built-in delay of 250 &#181;s before the E byte is sent to ensure
      that SIO protocol requirements are met and the OS can receive the byte properly.
    </dd>

    <dt>void complete();</dt>
    <dd>
      Send a Complete byte ($43) to the computer. This is used to signal completion
      of a successful command.
    </dd>
    <dd>
      There is a built-in delay of 250 &#181;s before the C byte is sent to ensure
      that SIO protocol requirements are met and the OS can receive the byte properly.
    </dd>

    <dt>void send_frame(Segment *seg, int offset, int length);</dt>
    <dd>
      Send a data frame to the computer from the given segment, starting at offset
      and with length bytes, not including the checksum. The range must fit within
      the segment. A standard SIO checksum is automatically appended at the end of
      the frame (1's complement of all payload bytes). Script execution is suspended
      until the send completes.
    </dd>
    <dd>
      Data is copied from the segment to an internal buffer as soon as the send request
      is queued, so any modifications to the segment after that are not reflected in
      the transfer. This is possible since memory access handlers can run in parallel
      to SIO transactions.
    </dd>
    <dd>
      There is a limit of 8192 bytes per frame sent.
    </dd>

    <dt>void recv_frame(int length);</dt>
    <dd>
      Receive a data frame from the computer with the given number of bytes, not
      including the checksum. The checksum is automatically checked and if it fails,
      a NAK is automatically sent and command processing is terminated. Script
      execution is suspended until the receive completes.
    </dd>
    <dd>
      When the frame is received, script execution is resumed. The received frame
      is available in a special segment called <tt>$sioframe</tt>. This segment
      is only valid during the current script until it exits or is suspended; if
      the data is required beyond that it should be copied into another segment.
      The <tt>$sioframe</tt> segment is read-only and cannot be mapped into a
      memory layer.
    </dd>
    <dd>
      There is a limit of 8192 bytes per frame received.
    </dd>

    <dt>void delay(int cycles);</dt>
    <dd>
      Suspend execution of the script for the given number of machine cycles.
    </dd>

    <dt>int command_asserted();</dt>
    <dd>
      Returns true if the SIO COMMAND line is asserted, indicating that a command
      frame is being transferred.
    </dd>

    <dt>int motor_asserted();</dt>
    <dd>
      Returns true if the SIO MOTOR line is asserted, meaning that the computer is
      requesting a tape deck to run or a communications device to take control of
      the SIO bus for non command frame based transfers.
    </dd>

    <dt>void enable_raw(int enable);</dt>
    <dd>
      Enables or disables raw SIO. This is needed to send raw bytes, signals on
      the SIO PROCEED or INTERRUPT lines, or to receive raw SIO events. However,
      performance is impacted when this is enabled, so it should only be enabled
      when needed. The default is disabled.
    </dd>
    <dd>
      Disabling raw SIO automatically deasserts the PROCEED and INTERRUPT lines,
      if they have been asserted.
    </dd>

    <dt>void set_proceed(int asserted);</dt>
    <dd>
      Asserts or deasserts the SIO PROCEED control line.
    </dd>
    <dd>
      Raw SIO must be enabled to use this method.
    </dd>

    <dt>void set_interrupt(int asserted);</dt>
    <dd>
      Asserts or deasserts the SIO INTERRUPT control line.
    </dd>
    <dd>
      Raw SIO must be enabled to use this method and it must be called on a script thread.
    </dd>

    <dt>int send_raw_byte(int ch, int cycles_per_bit);</dt>
    <dd>
      Send a raw byte on the SIO bus from the device to the computer's SIO DATA IN
      line.
    </dd>
    <dd>
      ch is the data byte to send, as it will be received in POKEY's SERIN register.
      Start and stop bits are automatically added around this byte, for a total of
      10 bits to transfer.
    </dd>
    <dd>
      While cycles_per_bit is the number of computer machine cycles between each bit.
      A value 93 is used for 19200 baud (19069-19245 baud).
    </dd>
    <dd>
      Raw SIO must be enabled to use this method and it must be called on a script thread.
      Thread execution is suspended until the byte is fully sent.
    </dd>

    <dt>int recv_raw_byte();</dt>
    <dd>
      Wait for a byte to arrive on the SIO bus and return the byte received. The bit rate
      in cycles per bit is stored in the thread-local <tt>$aux</tt> variable.
    </dd>
    <dd>
      Raw SIO must be enabled to use this method and it must be called on a script thread.
    </dd>
    <dd>
      <tt>recv_raw_byte()</tt> will not work if the <tt>sio_received_byte</tt> script
      event is bound.
    </dd>

    <dt>void wait_command();</dt>
    <dd>
      Wait for the SIO command line to assert, signaling the beginning of a command
      frame. Only a leading edge resumes execution; if SIO command is already asserted
      when this method is called, the method waits until the signal is deasserted and
      re-asserted.
    </dd>
    <dd>
      This method is intended for waiting for the beginning of a command frame.
    </dd>
    <dd>
      Raw SIO must be enabled to use this method and it must be called on a script thread.
    </dd>

    <dt>void wait_command_off();</dt>
    <dd>
      Wait for the SIO command line to be deasserted, signaling the not-command-frame
      state. If SIO command is already deasserted when this method is called, execution
      continues immediately.
    </dd>
    <dd>
      This method is intended for waiting until the computer is ready to receive the device
      ACK/NAK response to the command frame.
    </dd>
    <dd>
      Raw SIO must be enabled to use this method and it must be called on a script thread.
    </dd>

    <dt>void wait_motor_changed();</dt>
    <dd>
      Wait for the SIO motor line to change state from the current polarity. The
      <tt>motor_asserted()</tt> method can be used to check the state before or after this
      call.
    </dd>
    <dd>
      Raw SIO must be enabled to use this method and it must be called on a script thread.
    </dd>

    <dt>void reset_recv_checksum();</dt>
    <dd>
      Resets the checksum value accumulator for receive operations to zero.
    </dd>

    <dt>void reset_send_checksum();</dt>
    <dd>
      Resets the checksum value accumulators for send operations to zero.
    </dd>

    <dt>int get_send_checksum();</dt>
    <dd>
      Reads the computed SIO checksum for all bytes sent with raw SIO since the last call to <tt>reset_send_checksum()</tt>.
      This is the 8-bit one's complement sum of all bytes.
    </dd>
    <dd>
      Typically this is called after the payload of a data frame is sent, with the checksum
      computed by this method being sent afterward.
    </dd>

    <dt>int get_recv_checksum();</dt>
    <dd>
      Reads the computed SIO checksum for all bytes received with raw SIO since the last call to <tt>reset_recv_checksum()</tt>.
      This is the 8-bit one's complement sum of all bytes.
    </dd>
    <dd>
      When using this to verify the received checksum for a command or data frame, <tt>get_recv_checksum()</tt>
      should be called before the checksum is received, or else the checksum computation will also include the
      received checksum byte. For instance, when receiving a 128 byte data frame, the sequence would be:
      <tt>reset_recv_checksum()</tt>, 128x <tt>recv_raw_byte()</tt>, <tt>get_recv_checksum()</tt>, <tt>recv_raw_byte()</tt>,
      then compare the computed and received checksum bytes.
    </dd>
    <dd>
      The checksum accumulator is updated whenever a script receives a byte with <tt>recv_raw_byte()</tt>. It is
      not updated if a byte is received when a script is not waiting to receive (thus missing the byte).
    </dd>

    <dt>int check_recv_checksum();</dt>
    <dd>
      Compares the last byte received against the computed SIO checksum for all bytes received with raw SIO since
      the last call to <tt>reset_recv_checksum()</tt>, not including the last byte, and returns true if they
      match. This is a shortcut for saving the result of <tt>get_recv_checksum()</tt> and comparing it after receiving
      the checksum byte, allowing:
    </dd>
    <dd>
      <pre>  $sio.recv_raw_byte();
  if ($sio.check_recv_checksum())
    ...</pre>
    </dd>
  </dl>

  <h3>Clock</h3>
  <p>
    The <tt>$clock</tt> object provides methods to access the host real-time clock
    for emulating real-time clock devices.
  </p>
  <dl class="scripting-ref">
    <dt>void capture_local_time();</dt>
    <dd>
      Snapshot the current time in the current local time zone. This captures the local
      time in one pass so that accesses to individual fields are consistent. The local time is cached so
      that the time is not fetched more than once per script; it cannot be used to measure
      execution time within a script.
    </dd>

    <dt>int local_year();</dt>
    <dd>
      Return the year of the last captured local time as a four-digit value, e.g. 2020.
    </dd>

    <dt>int local_month();</dt>
    <dd>
      Return the month of the last captured local time (1-12).
    </dd>

    <dt>int local_day();</dt>
    <dd>
      Return the day of the month of the last captured local time (1-31).
    </dd>

    <dt>int local_dayofweek();</dt>
    <dd>
      Return the day of the week of the last captured local time as a value 0-6, where 0 means Sunday.
    </dd>

    <dt>int local_hour();</dt>
    <dd>
      Return the hour of the last captured local time (0-23).
    </dd>

    <dt>int local_minute();</dt>
    <dd>
      Return the minute of the last captured local time (0-59).
    </dd>

    <dt>int local_second();</dt>
    <dd>
      Return the second of the last captured local time (0-59).
    </dd>
  </dl>

  <h3>Controller ports</h3>
  <p>
    Controller port objects represent one of the 9-pin controller ports on
    the system, bound to a scripting variable with the <tt>controller_ports</tt>
    section.
  </p>
  <p>
    On a computer with only two controller ports (XL/XE), the third and fourth
    controller ports are disabled; they maintain state and all functions can be
    called, but the controller state is not applied to hardware state.
  </p>
  <dl class="scripting-ref">
    <dt>void set_paddle_a(int pos);</dt>
    <dt>void set_paddle_b(int pos);</dt>
    <dd>
      Sets the position of paddle A or paddle B, as the value returned from the
      <tt>POT0-7</tt> register and as reflected by the BASIC <tt>PADDLE()</tt>
      function. The valid range is 1-228; other values are clamped to this range.
    </dd>

    <dt>void set_trigger(int down);</dt>
    <dd>
      Sets the joystick trigger button state, where false means up and true
      means down.
    </dd>

    <dt>void set_dirs(int mask);</dt>
    <dd>
      Sets a bitmask of which joystick direction inputs should be asserted.
      Bits 0-3 correspond to up, down, left, and right, with a '1' bit meaning
      that the direction is active (grounded). This is inverted from the
      state as reflected in the PORTA/PORTB registers or reported by the
      BASIC <tt>STICK()</tt> function. Zero deactivates all inputs (joystick
      centered).
    </dd>
    <dd>
      As on the real hardware, the left and right inputs (bits 2-3) also
      double as the paddle triggers.
    </dd>
    <dd>
      When emulating a joystick, it is the responsibility of the device to not
      send both left+right or up+down to the computer. This is a valid input
      hardware-wise, but generally not possible with joystick hardware and some
      programs that use joysticks will malfunction if this is seen.
    </dd>
  </dl>

  <h3>Debug class</h3>
  <p>
    The <tt>Debug</tt> class contains methods to aid in development of custom
    devices.
  </p>
  <dl class="scripting-ref">
    <dt>static void log(String *s);</dt>
    <dd>
      Prints a string to the CUSTOMDEV logging channel in the debugger.
    </dd>

    <dt>static void log_int(String *s, int value);</dt>
    <dd>
      Prints a string to the CUSTOMDEV logging channel in the debugger, followed
      by an integer value formatted as decimal.
    </dd>
  </dl>

  <h3>Thread class</h3>
  <p>
    The <tt>Thread</tt> class contains methods to control execution of script
    threads. These methods only work with explicitly declared script threads; they
    cannot be used on the implicit threads created for direct script handlers or
    SIO command execution. However, those threads can control script threads.
  </p>
  <dl class="scripting-ref">
    <dt>int is_running();</dt>
    <dd>
      Returns true if the thread is currently running. This includes being temporarily
      suspended in a method call, or while waiting for its turn to execute (since
      only one thread can execute at a time).
    </dd>

    <dt>int run(function f);</dt>
    <dd>
      Starts execution of the specified function on the given thread. The function must
      return <tt>void</tt>. If the thread is currently running, it is stopped before
      being restarted at the beginning of the given function.
    </dd>
    <dd>
      <tt>run()</tt> cannot be called on the current thread.
    </dd>

    <dt>void interrupt();</dt>
    <dd>
      Stops execution on the thread, interrupting all currently executing functions on
      the thread's stack. For threads stopped in a yielding method, what side effects
      if any occur from the interrupted method call depend on the specific method.
    </dd>
    <dd>
      The currently executing thread cannot interrupt itself.
    </dd>

    <dt>static void sleep(int cycles);</dt>
    <dd>
      Suspends execution of the thread for the specified number of machine cycles (at 1.77/1.79MHz).
      Negative or zero values are silently ignored.
    </dd>
    <dd>
      This method cannot be used in an SIO command handler script, which must use <tt>$sio.delay()</tt>
      instead. The reason for this is that SIO command handling is sequenced through the SIO manager's
      action queue and it may virtualize actions that would ordinarily take time.
    </dd>
  </dl>

  <h2>Network server</h2>
  <p>
    For the most complex behaviors, the custom device can be linked to an
    external server. This is the slowest method of emulating behavior and can
    affect emulator performance, but permits the most complex behaviors and
    connections to external data and peripherals. The server communication is
    over a local TCP/IP socket and the server may be written in any language.
  </p>
  <p>
    A networked server is enabled with the "network" option:
  </p>
  <pre><![CDATA[  option "network": {
      port: 6502
  };
]]></pre>
  <p>
    "port" specifies the TCP/IP port to use for the server connection, which
    must be from 1024-49151. The emulator attempts to make a connection to
    this port on localhost. Connecting to servers on external hosts is not
    currently supported, due to latency and security issues.
  </p>
  <p>
    When enabled, the emulator connects to the specified server as soon as the
    custom device is instantiated. The server is required; if the connection
    fails or drops, the emulator may continue in degraded state but the custom
    device will not function correctly. Altirra will time out after one second;
    it will attempt to re-establish dropped connections, but the custom device
    state may be inconsistent between the emulation and the server until the
    next cold reset.
  </p>

  <h3>Enabling server actions</h3>
  <p>
    The server is invoked whenever certain simulator events happen or a memory
    layer control binding has an action type of "network". In this case, the
    emulator will send a command to the remote server and wait for it to
    respond with one or more commands for the emulator to perform to complete
    the action. This is a synchronous process, so the emulator is halted while
    waiting for the server responses and the server should respond as quickly
    as possible. However, except for rare events like system resets, the
    server is only invoked for events pertinent to the custom device.
  </p>
  <p>
    The communications protocol is a binary protocol, with packets exchanged
    in both directions. The details of the protocol are not described here, but
    deviceserver.py script is Python 3 script which handles this protocol.
  </p>
  <p>
    It is permitted for the server to improve throughput by overlapping commands,
    sending a new command before the reply to the previous one has been
    received. All commands are processed sequentially and the replies sent in
    the same order. However, the server must be prepared to receive data for
    earlier commands while in the middle of sending a new command. Otherwise,
    a deadlock may occur with the emulator unable to receive the new command due
    to being blocked on sending the response from the last one.
  </p>
    
  <h3>Events sent to the server</h3>
  <dl>
    <dt>Cold reset</dt>
    <dd>
      The emulated system is powering-on with everything reset except
      for non-volatile storage (memory and registers reset).
    </dd>

    <dt>Warm reset</dt>
    <dd>
      A system reset has occurred through the Reset button on the
      console; memory is preserved and only some registers are reset. Only devices
      intended to be internal devices should respond to this, as external devices
      like SIO peripherals and cartridges do not receive the reset signal.
    </dd>

    <dt>Read/write access</dt>
    <dd>
      A memory read or write has occurred to an address binding
      of network type. The server can issue commands for side effects related to
      the access, such as changes to memory layers. For a read access, the server
      must also respond with the byte value resulting from the read access.
    </dd>

    <dt>Debug read access</dt>
    <dd>
      A memory read access has occurred from the debugger. In
      this case, the server must respond with the same value that a read access
      would have provided, without any associated side effects. In other words,
      the debug read access must not affect the device state in any way.
    </dd>

    <dt>Explicit script call</dt>
    <dd>
      A script uses the <tt>$network</tt> object to get assistance from the remote
      server.
    </dd>
  </dl>

  <h3>Synchronous communication</h3>
  <p>
    Automatically reflected events and messages sent from script are handled
    in synchronous mode: the emulator stops execution and waits for the server
    to handle the event, processing all requests until the final reply from
    the server. These requests can include both querying and changing emulation
    state, such as modifying the contents of memory segments or changing memory
    layers. Processing is ended when the server sends the final reply -- which
    for some cases like memory reads also includes a return value -- and then
    execution resumes. The Request Types section below lists the requests that
    can be issued to the emulator during this processing.
  </p>
  <p>
    Script can manually send messages to the server using the <tt>$network.send_message()</tt>
    method, with two integer parameters. This allows for conditional or custom
    server communication.
  </p>
  <h3>Asynchronous communication</h3>
  <p>
    A downside to synchronous processing is that it lock-steps the emulator while
    it waits for the round-trip through the network stack and for the server
    to respond. Since emulation timing requirements are tight, this can slow down
    the emulator if communication is too frequent. Asynchronous communication
    can alleviate this, by allowing messages to be <i>posted</i> to the other
    side without requiring synchronization. For instance, the server can be
    notified that a byte was sent without waiting for a response. This greatly
    reduces the timing requirements and allows for pipelining between the emulator
    and server processes.
  </p>
  <p>
    For messages from the emulator to the server, the <tt>$network.post_message()</tt>
    method is used instead of <tt>send_message</tt>. This is a fire-and-forget
    call that does not wait for a response and does not return a value. In the other
    direction, <tt>req_interrupt()</tt> from Python invokes the script bound to
    the <tt>network_interrupt</tt> event. Both calls are naturally pipelined in
    the socket buffers, so it is up to script and the network server to implement
    a common protocol if throttling is required.
  </p>
  <p>
    The server may send any type of request to the emulator at any time, not just
    interrupts. The emulator services these at periodic intervals, typically within
    a frame (16-20ms in emulation time), but neither precise timing nor atomicity
    is guaranteed; two requests issued in quick succession outside of a sent message
    handling may execute on different ticks. However, requests are always processed
    in order.
  </p>
  
  <h3>Restrictions on script interrupts</h3>
  <p>
    Script interrupts are executed on a separate script thread and may execute
    suspendable methods, such as <tt>send_raw_byte</tt>. However, if another script
    interrupt arrives during this time, it will abort handling of the previous interrupt to
    service the new one.
  </p>
  <p>
    Executing calls from the script interrupt thread that require synchronous messages
    to the server is possible but discouraged, for a couple of reasons. The first
    is that it can result in undesirable request reordering:
  </p>
  <ul>
    <li>Server sends interrupt A</li>
    <li>Server sends request R</li>
    <li>Emulator begins processing interrupt A</li>
    <li>Emulator sends message to server</li>
    <li>Server issues request Ar and ends processing</li>
    <li>Emulator receives and executes request R</li>
    <li>Emulator receives and executes Ar</li>
  </ul>
  <p>
    In-order request processing and the network stream connection require that request
    R be received and handled by the emulator before request Ar associated with
    interrupt A. This is best avoided by performing the necessary actions within the
    script itself, which allows them to execute before other queued requests from
    the server.
  </p>
  <p>
    The second issue is script interrupt recursion. When the script interrupt thread
    sends a message to the server, it must execute any previously asynchronously
    queued requests from the server to process the replies to the sent message. If any
    of those previously queued messages is a script interrupt, those interrupts will
    be dropped.
  </p>

  <h3>Request types</h3>
  <p>
    The supported request types:
  </p>
  <dl>
    <dt>req_enable_layer</dt>
    <dd>
      Changes the mode of a memory layer to respond or not
      respond to reads and writes.
    </dd>

    <dt>req_set_layer_offset</dt>
    <dd>
      Changes the starting offset of a memory layer within
      its source segment. The segment must be direct map type and the new range
      must be contained within the segment. The contents of the segment are not
      changed.
    </dd>

    <dt>req_set_layer_segment_and_offset</dt>
    <dd>
      Changes both the source segment and the
      starting offset of a memory layer. The segment must be direct map type and
      the new range must be contained within the new segment. The contents of
      the segments are not changed.
    </dd>

    <dt>req_set_layer_readonly</dt>
    <dd>
      Changes whether a memory layer is read-only, i.e.
      blocks but does not respond to writes.
    </dd>

    <dt>req_read_seg_mem</dt>
    <dd>
      Reads data from a range in a segment. The range must be
      entirely contained within the segment.
    </dd>

    <dt>req_write_seg_mem</dt>
    <dd>
      Writes data to a range in a segment. The range must be
      entirely contained within the segment. Any direct-mapped layers mapping
      this segment will immediately reflect the new contents.
    </dd>

    <dt>req_copy_seg_mem</dt>
    <dd>
      Copies data from a range in a source segment to a range
      in a destination segment. This is much faster than doing segment reads and
      writes as it avoids sending the data across to the server. Copying between
      overlapping ranges in the same segment is allowed, in which case the copy
      direction is chosen to avoid corruption (similar to memmove() in C).
    </dd>

    <dt>req_interrupt</dt>
    <dd>
      Requests an interrupt to be delivered to script code, invoking the script
      handler for the <tt>network_interrupt</tt> event.
    </dd>
  </dl>

  <h2>Sample device descriptions</h2>
  <h3>8K cartridge</h3>
  <p>
    The following is a device description that implements a simple 8K cartridge
    designed to be inserted into the left slot of an 800. It loads a predefined
    image from a file and maps it to a hardcoded, read-only mapping at $A000-BFFF.
    This mapping is set as cartridge-enabled so that it is detected by the OS
    on XL/XE systems.
  </p>

  <pre><![CDATA[  option "name": "Sample 8K cartridge";

  Segment flash: {
      size: 8192,
      source: "cart.bin"
  };

  MemoryLayer wina: {
      name: "Left cartridge window",
      address: $A000,
      size: $2000,
      segment: {
        source: flash,
        offset: 0,
        mode: "ro"
      },
      cart_mode: "left"
  };]]></pre>

  <h3>Single-density disk drive</h3>
  <p>
    This device implements a single-density disk drive similar to the Atari 810.
    The ATR disk image is pre-loaded into a segment, and another segment is used
    to hold a predefined status response. The Status command simply sends
    the status segment; the Read and Write commands validate the sector number
    before transferring to or from the disk segment. The Write command is
    a mirror of the Put command.
  </p>
  <p>
    Note that writes to this device are ephemeral and are not written back to
    the image file.
  </p>

  <pre><![CDATA[  option "name": "Sample disk drive device";

  Segment disk: {
      source: "disk.atr",
      source_offset: 16,
      size: 92160
  };

  Segment status: {
      size: 4,
      init_pattern: [ 0, 0, 224, 0 ]
  };

  SIODevice disk_device: {
      device_id: $31,
      commands: [
        {
          id: $50,
          script: function {
            if ($aux <= 0 || $aux > 720)
                $sio.nak();
            else {
                $sio.ack();
                $sio.recv_frame(128);
                disk.copy(($aux - 1)*128, $sio_frame, 0, 128);
                $sio.complete();
            }
          }
        },
        {
          id: $52,
          script: function {
            if ($aux <= 0 || $aux > 720)
                $sio.nak();
            else {
                $sio.ack();
                $sio.complete();
                $sio.send_frame(disk, ($aux - 1)*128, 128);
            }
          }
        },
        {
          id: $53,
          auto_transfer: {
            mode: "read",
            segment: status,
            offset: 0,
            length: 4
          }
        },
        {
          id: $57, copy_from: $50
        }
      ]
  };]]></pre>
  <h2>Changes</h2>
  <dl>
    <dt>v0.3</dt>
    <dd>
      <ul>
        <li>JSON format replaced with common script-based format.</li>
        <li>Added conditional compilation.</li>
      </ul>
    </dd>

    <dt>v0.2</dt>
    <dd>
      <ul>
        <li><tt>cctl_mode</tt> can now be <tt>auto</tt>.</li>
        <li><tt>offset</tt> is now optional for SIO auto transfers.</li>
        <li><tt>controller_ports</tt> added.</li>
        <li><tt>vblank</tt> script event added.</li>
      </ul>
    </dd>
  </dl>

</topic>