<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="index.xsl" ?>
<topic title="Custom device specification, v0.5">
  <toc/>
  <h2>Basic device description structure</h2>
  <p>
    An .atdevice file is a text file that describes the device and its core
    functionality. The file consists of a series of declarations which describe
    the parts of the custom device:
  </p>
  <pre>  // Comment
  option "name": "My custom device";

  Segment status_seg: {
      size: 4
  };

  function void init_status() {
      status_seg.write_byte(3, $E0);
  }

  event "cold_reset": function {
      init_status();
  }</pre>

  <p>
    The file is mostly processed in order from the beginning. Except for cases where one section
    refers to another, sections can generally be mixed in any order within the device description file.
  </p>

  <h3>Top-level statements</h3>
  <p>
    At the top level, the device description is a series of statements. Each statement ends with
    a semicolon, no matter how many lines it spans. The exception is a function, which ends with a closing
    brace without a semicolon; this is to be syntactically familiar to the C programming language.
  </p>

  <h3>Literal values</h3>
  <p>
    Integer constants can be specified either as decimal or hexadecimal (base 16). Hex constants are prefixed
    with <tt>$</tt> (not <tt>0x</tt>).
  </p>
  <p>
    String constants are specified within double quotes, e.g. <tt>"abc"</tt>.
  </p>

  <h3>Variables</h3>
  <p>
    Variables are used to store values used or modified by a device, as well as objects used to interact with
    the host emulation. Variables are <i>statically typed</i>: they are always defined with a type and can only ever
    hold values of that type.
  </p>
  <p>
    There are two types of variables. Variables of primitive type, currently only type <tt>int</tt>, are
    modifiable by script and used to hold device state. These are described in the Scripting section.
    They may also be of class object type, such as <tt>Segment</tt> for data segments, or <tt>MemoryLayer</tt>
    for emulation memory layers. Defining a variable of object type usually unlocks behaviors in the custom
    device, such as enabling serial I/O bus support.
  </p>
  <p>
    Variable names start with a letter or an underscore (<tt>_</tt>), followed by zero or more letters,
    numbers, or underscores. A variable name cannot contain spaces, dollar signs (<tt>$</tt>), or non-ASCII
    characters. Both lower and upper case may be used in variable names, and case is significant: <tt>abc</tt>
    and <tt>Abc</tt> are different variables. Variables must have unique names even if they are of different
    types.
  </p>
  <p>
    The following names are reserved as keywords in a device file and are not available as variable names:
  </p>
  <table border="0" class="cd-keywords">
    <tr>
      <td>else</td>
      <td>event</td>
      <td>false</td>
      <td>function</td>
    </tr>
    <tr>
      <td>if</td>
      <td>int</td>
      <td>loop</td>
      <td>option</td>
    </tr>
    <tr>
      <td>return</td>
      <td>true</td>
      <td>void</td>
    </tr>
  </table>
  <p>
    A global variable is declared at top-level with the type followed by the variable name, and ending
    with a semicolon:
  </p>
  <pre>  int current_bank;
  Thread recv_thread;</pre>

  <h3>Functions</h3>
  <p>
    <i>Functions</i> hold statements that drive device logic. They are declared using the <tt>function</tt>
    keyword:
  </p>
  <pre>  function void reset_bank() {
      bank = 0;
  }</pre>
  <p>
    These are described in more detail in the Scripting section. A function by itself does nothing unless
    it is called, typically from an event handler or a memory access binding.
  </p>

  <h3>Structured data</h3>
  <p>
    Many object types require structured data to configure the object when it is created. This
    is specified with a colon after the variable name, followed by the data:
  </p>
  <pre>  Segment status_buffer: { size: 4 };</pre>
  <p>
    The object data is structured similarly to JSON, with some syntax adaptations. The top-level data
    value can be a boolean (<tt>true</tt> or <tt>false</tt>), an integer, a function, a variable, an array, or an data object.
    Arrays and data objects can in turn contain sub-values, creating a tree of nested values.
  </p>
  <p>
    Arrays are specified with <tt>[brackets]</tt> and contain a comma-separated list of sub-values,
    e.g. <tt>[1, 2, "abc"]</tt>. The values may be of different types. The array can also be empty: <tt>[]</tt>.
  </p>
  <p>
    Data objects are contained within <tt>{braces}</tt> and have a comma-separated list of named members. Each
    member is specified with the form <tt>name: value</tt>, where the name is a valid variable name. <tt>{ x: 4, y: 7 }</tt>
    and <tt>{}</tt> are valid data objects. Member names must be unique within an object. Unlike in JSON, however, the name is not quoted.
  </p>
  <p>
    Variables are referenced in a few cases within object data, particularly to connect to segments. These
    are simply specified by the variable name without quotes.
  </p>
  <p>
    Finally, object data may have inline script functions, which are small fragments of script code within
    the object data itself. The syntax is <tt>function { ... }</tt>, where the body of the function is
    specified within the braces.
  </p>

  <h3>Options</h3>
  <p>
    The <tt>option</tt> statement is used to set miscellaneous device parameters. The syntax is:
  </p>
  <blockquote>
    <tt>option "</tt><i>option-name</i><tt>": </tt><i>option-value</i><tt>;</tt>
  </blockquote>
  <p>
    The option value is a structured data value which depends on the option. One option is <tt>"name"</tt>,
    which is a string that determines the display name of the device in UI. Another is <tt>"network"</tt>,
    which enables a connection to the network server.
  </p>
  <p>
    The option <tt>"debug"</tt> is handled by the compiler itself. The option value is either <tt>true</tt>
    or <tt>false</tt> and determines whether conditional code prefixed by the <tt>[debug]</tt> attribute
    is compiled. This allows logging statements and debugging code to be quickly turned on and off by
    changing the option value.
  </p>
  
  <h3>Comments and whitespace</h3>
  <p>
    Most constructs in device descriptions are terminated by a semicolon or delimited by braces and are
    insensitive to whitespace and layout. A statement or definition can be freely split across as many
    lines as necessary. Indentation may also be used without affecting the meaning of the definitions or
    code. Either hard tabs or soft tabs (spaces) can be used.
  </p>
  <p>
    Comments start with two forward slashes (<tt>//</tt>). Everything from that point to the end of the
    line is ignored.
  </p>

  <h2>Segments</h2>
  <p>
    Custom devices may have one or more segments, which are uncommitted buffers
    of data. Each segment has a name for referencing, a fixed size, and an
    optional initialization pattern:
  </p>
  <pre>  Segment rom: {
      size: 8192,
      source: "cart.bin"
  };

  Segment ram: {
      size: 8192,
      init_pattern: 255
  };

  Segment nvram: {
    size: 256,
    init_pattern: [0, 255],
    persistence: "nonvolatile"
  };
  </pre>
  <p>
    Segments have multiple uses, including backing memory for memory layers,
    loading predefined blobs from files, and writable temporary storage.
    Segments may be any size, including zero bytes, subject to implementation
    limits. Currently, Altirra limits the total size of all segments to 256MB.
  </p>
  <p>
    The member key is the segment name used to reference it from other parts.
    It is case sensitive and must conform to the naming conventions of the
    scripting engine.
  </p>
  <h3>Initialization data</h3>
  <p>
    The segment may be initialized with either source data or an initialization
    pattern. For source data, the source is a filename in the same location as
    the .atconfig file. Only a filename is allowed, no relative or absolute
    paths allowed. Altirra does support ATVFS paths for this, which allows the
    source to be zipped or gzipped (gz://file.bin or zip://file.zip/subfile.bin).
  </p>
  <p>
    For initialization data, the init data is a blob as specified earlier. The
    init data may be from 1-N bytes where N is the size of the segment. If the
    init data is shorter than the segment, it is repeated as needed to fill the
    segment.
  </p>
  <p>
    If no source or initialization data is given, the segment memory is zeroed.
  </p>
  <h3>Persistence</h3>
  <p>
    By default, segments that are not backed by data are volatile and will be
    automatically reinitialized on cold reset. This can be overridden with the
    "persistence" property:
  </p>
  <dl>
    <dt>volatile (default)</dt>
    <dd>
      The segment is reset to its initialization state on
      cold reset. This has no effect on segments that are backed by file.
    </dd>

    <dt>nonvolatile</dt>
    <dd>
      Auto-reinitialization on cold reset is disabled. This is
      useful for segments that are preinitialized by an init script.
    </dd>
  </dl>

  <h2>Memory layers</h2>
  <p>
    Memory layers allow the custom device to interact with the emulated CPU
    using memory mapped I/O. A memory layer is a contiguous memory address range,
    enabled for some or all types of accesses. More precisely:
  </p>
  <ul>
    <li>
      The address range of a memory layer is contiguous and page aligned, within
      the 64K address space.
    </li>
    <li>
      A memory layer may be enabled or disabled independently for both reads and
      writes. ANTIC and CPU reads are handled identically.
    </li>
    <li>
      Memory layers have a defined priority relative to other memory layers.
      A higher priority memory layer can intercept accesses and prevent them
      from being seen by lower layers. Currently, this is fixed at cartridge
      priority (see the output of the .map debugger command).
    </li>
    <li>
      Memory layers can either be directly mapped to a segment or bound to
      a set of address bindings. Direct segment mapping is faster and preferred
      when possible, but requires that the memory layer be a solid mapping.
    </li>
  </ul>
  <pre><![CDATA[
  MemoryLayer wina: {
    name: <Debugger readable name>,
    address: <Starting address of memory layer, page-aligned>,
    size: <Length of memory layer, in bytes>,

    // for layers with a direct segment mapping
    segment: { ... },

    // for dynamically controlled memory layers
    control: { ... },

    // for cartridge-enabled layers (optional)
    cart_mode: ...

    // for PBI-enabled layers (optional)
    auto_pbi: ...

    // optional
    priority: "..."
  };]]></pre>
  <p>
    A memory layer must either be "segment" or "control" type, but not both. A
    layer defined with <tt>segment</tt> is a direct mapped layer suitable for
    plain memory mapping, while a layer defined with <tt>control</tt> is a binding
    controlled layer more suitable for hardware registers or complex memory
    mappings.
  </p>
  <p>
    name (required): The name of the memory layer, as it appears in the
    debugger's <tt>.map</tt> command. This name is only shown in the debugger
    and need not be unique, though recommended.
  </p>
  <p>
    address (required): The 16-bit base address of the memory layer's access
    window. This determines the base address of the memory layer as seen by
    the 6502 or ANTIC. This must be aligned to a page boundary, e.g. <tt>$4000</tt>
    or <tt>$D100</tt>.
  </p>
  <p>
    size (required): The size of the memory layer access window, in bytes.
    This must be a multiple of 256 for page alignment, and the resulting address
    region must fit within the 64K address space. Note that this is the size
    of the access window and not the backing memory, which may be much bigger
    than the backing memory to support bank switching.
  </p>
  <p>
    cart-mode (optional): Enables automatic cartridge behavior for this
    memory layer. See <i>cartridge-enabled layers</i> below for more info.
  </p>
  <p>
    auto_pbi (optional): Enables automatic Parallel Bus Interface (PBI) behavior
    for this memory layer. See <i>PBI-enabled layers</i> below for more info.
  </p>
  <p>
    priority (optional): Sets the relative priority of this layer to resolve
    conflicts when this memory layer overlaps with another memory layer. The
    prioritization is as follows:
  </p>
  <ul>
    <li>(Highest priority)</li>
    <li class="highlighted">Custom memory layers marked as <tt>priority: "hwoverlay"</tt></li>
    <li>Base hardware registers</li>
    <li class="highlighted">Custom memory layers marked as <tt>auto_pbi</tt> or <tt>priority: "pbi"</tt></li>
    <li class="highlighted">Default priority for custom memory layers (cartridge)</li>
    <li>OS, BASIC, and Self-Test ROM</li>
    <li class="highlighted">Custom memory layers marked as <tt>priority: "extsel"</tt></li>
    <li>Extended RAM (PORTB / 130XE)</li>
    <li>Base 64K RAM</li>
    <li>(Lowest priority)</li>
  </ul>
  <h3>Direct mapped layers</h3>
  <p>
    A <i>direct mapped layer</i> is a layer that is directly mapped to segment
    memory. Layers with a direct segment mapping have the following members:
  </p>
  <pre><![CDATA[  segment: {
    source: <segment-variable>,
    offset: <byte offset from start of segment>,
    mode: "r|ro|w|rw|wt"
  }]]></pre>

  <p>
    source (required): The name of the segment to use. Note that this is a
    direct variable reference and not a string, so it isn't quoted.
  </p>
  <p>
    offset (required): The byte offset from the start of the segment to map.
    The mapped range must be page-aligned and be contained entirely within
    the source segment. It is allowed to map part of a segment but the memory
    layer may not extend beyond the end of the segment.
  </p>
  <p>
    mode (required): The memory access mode for the layer. "r" and "w" mean
    reads and writes, respectively. A "r" mode mapping will handle reads but
    allow writes to pass through to lower priority layers; an "rw" mapping will
    handle both reads and writes. An "ro" mode layer is read-only and will block
    writes to lower layers without modifying the mapped segment. "wt" selects
    write-through mode, where writes are stored in the segment without blocking
    the writes from lower priority layers.
  </p>
  <p>
    Mapping overlapping segment ranges in more than one memory layer
    simultaneously is supported. In this case, reads to the layers return the
    same data and writes to any of the layers are reflected in the other layers.
    This is used to implement address mirroring or dual banking windows.
  </p>
  <p>
    A direct mapping does NOT require that the memory layer always map to a fixed
    location in the segment. The memory layer cannot be changed to binding-based
    mappings on the fly, but it can be revectored to different offsets or
    segments under script control.
  </p>

  <h3>Binding-controlled layers</h3>
  <p>
    A layer with a "control" member is a binding-controlled layer. Each binding
    determines the response for a unique address range and access type in the
    memory layer. This allows behavior specification down to byte granularity.
  </p>
  <p>
    The value of the control member is an array of objects:
  </p>
<pre><![CDATA[  [
    {
      address: <starting address>,
      size: <optional size in bytes>,
      mode: "r|w|rw",

      // one of "data", "action", or "script" required
      data: <data-blob>,
      action: "block|network",
      script: "...",
      debug_script: "..."
    }
  ]]]></pre>
  <p>
    address (required): The absolute starting address of the binding. This must
    be within the address range of the layer.
  </p>
  <p>
    size (optional): The size of the binding in bytes. Must be non-zero and
    the entire binding must fit within the layer. If omitted, the binding is one
    byte in size.
  </p>
  <p>
    mode (required): Whether the binding applies only to read accesses ("r"),
    write accesses ("w"), or both read and write accesses ("rw"). Both the layer
    and binding modes apply and the effective mode is the intersection of the
    two, i.e. an "rw" binding will not respond to writes in an "r" or "ro" mode
    layer.
  </p>
  <p>
    All bindings must have a unique address range and mode. They can overlap in
    addresses for different modes, i.e. $4000/r and $4000/w. It is OK for some
    addresses to not be covered by a binding, in which case they are pass-through
    to lower layers.
  </p>
  <p>
    The response of a binding to a matching access is specified by one of the
    following members:
  </p>
  <dl>
    <dt>"data"</dt>
    <dd>
      Return the given constant blob data. The blob data must either one
      byte to repeat for the entire address range of the binding, or a blob the
      same size as the binding. Data responses are only valid for read bindings.
    </dd>
    <dt>"action"</dt>
    <dd>
      Specifies a special action:

      <dl>
        <dt>"block"</dt>
        <dd>
          Prevent lower layers from seeing the access. This is only valid
          for write bindings.
        </dd>

        <dt>"network"</dt>
        <dd>
          Send the access to the remote server.
        </dd>
      </dl>
    </dd>

    <dt>"script"</dt>
    <dd>
      Specifies a script to run on the read or write access. For write
      bindings, no return value is needed. For read or read/write bindings, the
      byte result of the read access must be returned. The result does not need
      to be restricted to 0-255; for convenience, the lowest 8 bits are used and
      any higher bits are ignored.
    </dd>

    <dt>"debug_script"</dt>
    <dd>
      For read or read/write bindings using the script method,
      a debug script can also be supplied to handle debug reads differently by
      suppressing side effects. This avoids altering machine state when the
      debugger inspects memory. For instance, an address that would normally
      trigger a bank switch on a read should have a debug read override to
      prevent the bank switch.
    </dd>
    <dd>
      If <tt>debug_script</tt> is not specified, the same <tt>script</tt> is used for
      both debug and non-debug reads. The <tt>[debug_read]</tt> and <tt>[!debug_read]</tt>
      attributes can be used to conditionally compile statements for only one of
      the modes. See Conditional Compilation in the scripting section for details.
    </dd>

    <dt>"variable"</dt>
    <dd>
      Read or write the named variable: <tt>"variable": "r0"</tt> causes the variable
      <tt>r0</tt> to be read or written on accesses to the given address.
    </dd>
    <dd>
      If the value of the variable exceeds the range of a byte (0-255), the lowest 8 bits
      are taken on a read access.
    </dd>

    <dt>"copy_from"</dt>
    <dd>
      "copy_from": Copies bindings from another address in the same layer. The
      value is the starting address to copy from. For instance, given a layer at
      $D500-D5FF, <tt>"address": "$D580", "mode": "r", "copy_from": "$D500"</tt>
      will copy bindings from $D500-D57F to $D580-D5FF.
    </dd>
    <dd>
      The source bindings must be declared before the copy_from entry. The copy
      is always ascending so that a pattern can be repeated:
    <pre>{ address: $D500, mode: "rw", variable: "r0" },
{ address: $D501, mode: "rw", variable: "r1" },
{ address: $D502, mode: "rw", variable: "r2" },
{ address: $D503, mode: "r", variable: "status" },
{ address: $D504, size: 252, mode: "rw", copy_from: $D500 }
    </pre>
      This copies $D500-D503 to $D504-D5FF, which causes the first four entries
      to be repeated.
    </dd>
  </dl>

  <h3>Cartridge-enabled layers</h3>
  <p>
    The cart_mode member specifies that a memory layer is intended for a
    cartridge and should be connected to the emulator's cartridge logic:
  </p>
  <ul>
    <li>
      Memory layers assigned to the left cartridge slot automatically assert
      the RD5 signal when active. This affects the TRIG3 input on XL/XE
      computers that indicate the presence of a cartridge, as well as
      cartridge sensing for pass-through cartridge ports.
    </li>
    <li>
      Pass-through cartridge ports can disable cartridge-enabled memory layers.
      This happens independently of the mapping mode of the layer.
    </li>
  </ul>
  <p>
    Both direct-mapped and binding-controlled layers can be cartridge-enabled.
  </p>
  <p>
    There are three cartridge enable modes available:
  </p>
  <dl>
    <dt>cart_mode: "left"</dt>
    <dd>
      Hook the layer into the S5-to-RD5 signal chain for the $A000-BFFF address
      range (left cartridge region).
    </dd>

    <dt>cart_mode: "right"</dt>
    <dd>
      Hook the layer into the S4-to-RD4 signal chain for the $8000-9FFF address
      range (right cartridge region).
    </dd>

    <dt>cart_mode: "cctl"</dt>
    <dd>
      Hook the layer into the CCTL signal for the $D500-D5FF cartridge control region.
    </dd>

    <dt>cart_mode: "auto"</dt>
    <dd>
      Select left, right, or cctl modes based on the address range of the memory layer.
    </dd>
  </dl>
  <p>
    Cartridge-enabled layers are not restricted to cartridge ranges and can
    map ranges outside of the normal cartridge address spaces ($8000-BFFF and
    $D500-D5FF).
  </p>
  
  <h3>PBI-enabled layers</h3>
  <p>
    A memory layer marked as <tt>"auto_pbi": true</tt> is automatically enabled only when
    the PBI device is selected. It can only be used when <tt>pbi_device</tt> is declared
    in the device specification.
  </p>

  <h3>Hardware address ranges</h3>
  <p>
    The hardware address range of <tt>$D000-D7FF</tt> contains many address ranges dedicated
    to motherboard resources. This includes GTIA in page $D0, POKEY in page $D2, and
    ANTIC in page $D4. Currently, these cannot be overlaid by custom device memory layers.
    Pages $D1 and $D5-D7 can be overlaid, with the except of the single address $D1FF being
    intercepted if PBI devices are present.
  </p>
  <p>
    The presence of memory layers in the $D1 and $D5-D7 pages will also affect the emulator's
    ability to allocate those pages for high-level emulation hooks, particularly CIO devices
    like the <tt>H:</tt> device. The custom device code will automatically advertise any memory
    layers overlapping these regions so that the hook page can relocated to avoid them.
    This happens whether or not the layers are enabled, as the layer modes can be changed
    on the fly.
  </p>

  <h2>Serial I/O (SIO) devices</h2>
  <p>
    Custom devices can also connect to the serial I/O bus to emulate SIO peripherals.
    This is done in cooperation with the central SIO management code, allowing
    custom peripherals to benefit from common logging and acceleration code that
    is also used by the internal device emulators.
  </p>
  <h3>Declaring SIO devices</h3>
  <p>
    SIO devices are declared as objects of type <tt>SIODevice</tt>:
  </p>
  <pre>  SIODevice disk_device: {
      device_id: $31,
      commands: ...
  };

  SIODevice printer_device: {
      device_id: $40,
      device_count: 4,
      commands: ...
  };</pre>
  <p>
    <tt>device_id</tt> indicates the device ID as seen on the SIO bus. <tt>device_count</tt>,
    if present, specifies that more than one device ID should be handled, starting at the given
    device ID. This is used to claim a range of device IDs without having to repeat the command
    definitions.
  </p>
  <p>
    The custom device will only respond to commands for the given device IDs. Commands for other
    device IDs are ignored and not seen by the custom device. It is assumed that all of the
    device IDs are being implemented by a single physical device that can only handle one command
    at a time, so it is not possible for the custom device to handle simultaneous commands to
    different devices or the same device.
  </p>
  <h3>Declaring SIO commands</h3>
  <p>
    The <tt>commands</tt> member of a device declaration contains the list of commands supported
    by that device. It is an array of objects, one for each command:
  </p>
  <pre>
    commands: [
      { id: $48 },
      {
        id: $53,
        auto_transfer: { mode: "read", segment: "status", offset: 0, length: 4 }
      },
      {
          id: $50,
          script: function {
              $sio.ack();
              $sio.recv_frame(128);
              disk.copy(($aux - 1)*128, $sio_frame, 0, 128);
              $sio.complete();
          }
      },
      { id: $57, copy_from: $50 }
    ]
  </pre>
  <p>
    The <tt>id</tt> member is required and specifies the command ID for the command, as specified
    by the second byte in the SIO command frame. All commands within a device must have unique IDs.
    This can also be the special name <tt>default</tt>, which means all commands not already implemented.
  </p>
  <p>
    A command with only <tt>id</tt> simply returns ACK and then Complete, implementing a no-op command
    that completes successfully without doing anything.
  </p>
  <p>
    A command with <tt>auto_transfer</tt> implements a command that automatically issues a read transfer
    from a segment or a write transfer to a segment. The <tt>mode</tt> member specifies the transfer
    direction, from the standpoint of the computer. A <tt>read</tt> command allows the computer to read
    from a device segment, while <tt>write</tt> has the computer writing to a device segment. <tt>segment</tt>
    specifies the segment name, while <tt>offset</tt> and <tt>length</tt> specify the starting offset
    in the segment and the transfer length. The transfer range must fit within the segment.
  </p>
  <p>
    <tt>script</tt> is the most flexible option as it runs a script to drive the SIO transaction. The
    script has access to the SIO command frame and can send command status bytes as well as sending or
    receiving data frames. It can also inject delays.
  </p>
  <p>
    Finally, a <tt>copy_from</tt> command copies a command definition to another command ID, reusing it.
    The value is the command ID to copy from, which must have been declared earlier. One use for this is
    to reuse the same commmand definition for the Put and Write commands of a disk drive.
  </p>

  <h3>SIO protocol handling</h3>
  <p>
    The command frame is automatically validated prior to dispatching to the command handlers. A command
    frame target at a device ID not declared in the custom device is ignored. Command frames with
    a matching device but a non-matching command are NAKed. Command frames with invalid checksums are
    ignored.
  </p>
  <p>
    For non-script commands, the entire protocol is handled by the host. For scripted commands, the
    script begins execution after the command line is deasserted and is responsible for everything
    including sending the initial ACK/NAK for the command. This is done through the <tt>$sio</tt>
    object, which has methods for all remaining bus transactions needed.
  </p>
  <p>
    The high-level flow that scripts need to implement for standard SIO transactions is as follows:
  </p>
  <ul class="spaced">
    <li>
      Check if the command is valid. If it is not, send a NAK (<tt>$sio.nak()</tt>) and end command processing. An example
      of a condition that should cause a command NAK is a Read Sector command to a disk drive with
      an invalid sector number. Checks done here can generally only depend upon immediate device and command state since
      the ACK/NAK must be sent in 16ms; a disk drive could not read or write sectors before sending the command ACK/NAK,
      for instance.
    </li>
    <li>
      ACK the command (<tt>$sio.ack()</tt>).
    </li>
    <li>
      If the command is a write command, where the computer writes data to the device:
    </li>
    <ul>
      <li>Receive the data frame from the computer (<tt>$sio.recv_frame()</tt>).</li>
      <li>[The host will automatically NAK the data frame and end the script here if a checksum error occurs.]</li>
      <li>ACK the data frame (<tt>$sio.ack()</tt>).</li>
      <li>Process the data frame.</li>
    </ul>
    <li>
      Send Complete (<tt>$sio.complete()</tt>) or Error (<tt>$sio.error()</tt>) depending on whether
      the operation completes successfully. Note that command processing does <b>not</b> stop here
      on Error, since a data frame still needs to be sent even if it has no useful data in it.
    </li>
    <li>
      If the command is a read command, where the computer reads data from the device:
    </li>
    <ul>
      <li>Send the data frame to the computer (<tt>$sio.send_frame()</tt>).</li>
    </ul>
  </ul>
  <p>
    The current command is automatically aborted by the host if the SIO command line is asserted before
    the command completes or a reset event occurs.
  </p>

  <h3>Protocol timing</h3>
  <p>
    The SIO protocol has minimum and maximum timing requirements between phases of bus transactions.
    These are mainly related to periods where either the computer or the peripheral need to reconfigure
    its serial interface between sending and receiving data. Violating minimum bounds can cause lost
    or corrupted data bytes, while violating maximum bounds results in timeouts.
  </p>
  <p>
    When implementing a custom device, all timings are in emulation time, where time only passes when
    the script deliberately executes a delay or sends or receives bytes. All other actions, such as
    executing a script or performing a network transaction take zero emulation time since the 6502 does
    not run. Making a network call that takes too long will slow down the emulator but not change the
    timing relationship between the 6502, the chipset, and the device. Thus, in general, there are no
    problems with the custom device being too slow to respond.
  </p>
  <p>
    Where problems <i>can</i> occur is with the custom device being too fast in emulation time, violating
    minimum bounds because it can do all processing in zero time.
    To prevent this, the custom device host automatically inserts delays into specific parts of the
    transaction:
  </p>
  <ul>
    <li>The command handler starts running after the command line is deasserted, so the script can send the command frame ACK/NAK immediately.</li>
    <li>A delay of 850 &#181;s is inserted before the ACK/NAK of a received data frame.</li>
    <li>A delay of 250 &#181;s is inserted before Error/Complete bytes.</li>
  </ul>
  <p>
    Therefore, no explicit delays are needed in a script to meet minimum timing requirements. A script
    may freely call <tt>ack()</tt>, <tt>complete()</tt>, and <tt>send_frame()</tt> back-to-back and
    the custom device engine will ensure that the minimum protocol delays are observed.
  </p>

  <h3>Using sent/received data</h3>
  <p>
    Typically a custom SIO device will use additional segments to handle data
    transfers, such as a disk image segment or a status frame segment. These segments
    should be marked with <tt>nonvolatile</tt> persistence so that they are not reset
    when the peripheral is power-cycled. This is only needed if they are not file-sourced,
    however, as those are implicitly nonvolatile.
  </p>
  <p>
    Canned replies, such as Status requests from some devices, can put the predefined
    reply into a segment with an <tt>init_pattern</tt> and use the <tt>auto_transfer</tt> mode, allowing the host to
    drive the entire SIO protocol. Otherwise, the <tt>Segment.copy()</tt> method is
    useful in SIO command scripts, particularly in write commands to copy from the
    <tt>$sioframe</tt> receive segment to a work segment. This is less needed for
    read commands, which can <tt>send_frame()</tt> directly from segments.
  </p>


  <h3>Concurrency with other scripts</h3>
  <p>
    Because SIO command scripts can be suspended by a send/receive operation or an explicit delay,
    they can run in parallel with other scripts in the custom device, most notably memory access handlers.
    Only one script can execute at a time, so the scripts can only switch off at suspension points -- there
    is no risk of data races as in a multi-core CPU. However, global state variables may change if shared
    between the scripts.
  </p>
  <p>
    Some special variables are instanced per thread and not shared. In particular, the <tt>$timestamp</tt>
    variable is thread-local. In an SIO script, it always gives the timestamp of the start of script
    execution regardless of suspend points within the script. Any other scripts that execute during the
    command receive their own <tt>$timestamp</tt> values.
  </p>


  <h3>Accelerated transfers</h3>
  <p>
    Two types of acceleration can be implemented by the host, burst I/O transfers and HLE accelerated transfers.
    Both are handled automatically and do not require handling by script. Acceleration support is controlled
    by device ID, so enabling D: acceleration will affect both internal and custom devices that use $31-3F
    device IDs.
  </p>
  <p>
    In a burst I/O transfer, handshaking is implemented between POKEY and the device so that the time
    between serial input ready interrupts is shortened, depending on how fast the 6502 can acknowledge it.
    This results in the effective transfer rate rising above 19,200 baud adaptively to as fast as the serial
    IRQ handler can handle. For a custom device, this results in <tt>recv_frame()</tt> operations occurring
    more quickly than normal.
  </p>
  <p>
    HLE acceleration uses CPU interception instead and transfers data directly between memory and the device.
    When this occurs, SIO operations are short-circuited and occur in zero time. All delays are skipped,
    ACK/NAK/Complete/Error bytes are handled directly, and serial transfers occur immediately via DMA.
    The HLE code does some checks for whether accelerating the transfer is safe and will skip doing so in
    some cases, such as if it cannot verify that the OS SIO routines are being used or the transfer overlaps
    OS variables that would be used in the transfer. It also assumes that the device implementation conforms
    to the standard SIO protocol and that at most one read or write data frame transfer takes place, which
    is compared against the DCB parameters to determine the resulting status and buffer contents.
  </p>
  <p>
    HLE acceleration can be disabled on either a device or command basis by specifying <tt>"allow_accel": false</tt>
    in the device or command object.
  </p>
  
  <h3>Raw SIO transfers</h3>
  <p>
    For the lowest level of SIO device emulation, a custom device can bypass the SIO manager and use raw SIO
    to directly send and receive bytes on the SIO bus. This allows full control over transfer format and
    timing and permits emulation of SIO devices that do not use standard SIO command frames, such as
    serial port devices.
  </p>
  <p>
    To use raw SIO, one or more script threads must be set up to handle transfers on the SIO bus and raw
    SIO must then be enabled. This can be done either autonomously or triggered from an SIO command, depending
    on the requirements of the custom device. However, in the latter case, the SIO command script itself
    cannot drive the raw SIO transaction -- it must hand off to a worker thread to do so:
  </p>
  <pre><![CDATA[  Thread rawsio_thread;

  void handle_raw_transfer() {
    $sio.enable_raw(true);

    $sio.send_raw_byte($00, 94);
    Thread.sleep(100);
    $sio.send_raw_byte($01, 94);
    $sio.send_raw_byte($02, 94);
    int data = $sio.recv_raw_byte();

    $sio.enable_raw(false);
  }

  void handle_command() {
    $sio.ack();
    $sio.complete();
    rawsio_thread.run(handle_raw_transfer);
  }]]></pre>
  <p>
    A single thread can be used for both sending and receiving or two threads can handle the two directions
    independently, depending on whether the emulated device uses half-duplex or full-duplex communication.
    A disk drive can use one thread since its controller typically can only handle half-duplex, whereas a serial
    device would use two threads for full-duplex operation.
  </p>
  <p>
    The <tt>SIO</tt> class provides some assistance for common SIO emulation patterns. Wait functions are
    provided to efficiently wait for transitions on the SIO command line, to synchronize phases of the SIO
    command protocol or allow a monitoring thread to efficiently interrupt serial transfer. Checksums are
    also automatically computed for bytes sent and received by script, avoiding the need to manually re-compute
    the checksums for verification.
  </p>
  <p>
    When raw SIO is active, all standard SIO command processing for the custom device is suspended. If standard
    SIO command processing is desired, raw SIO must be cancelled prior to the trailing (deasserting) edge of
    the SIO command line for the custom device's SIO command tables to be re-enabled. However, all other devices
    in the system will still monitor for standard SIO commands regardless of the custom device's raw SIO state,
    as occurs in an actual SIO device chain on real hardware.
  </p>

  <h3>Conflicts with built-in devices</h3>
  <p>
    A custom device may not work correctly if it attempts to implement an SIO device that is also
    being handled by an active internal device in the emulator. This is the emulation equivalent of a bus
    fight. In these cases, the internal device must be disabled for the custom device to work.
  </p>
  <p>
    In Altirra, the most likely conflict of this type is with the disk emulator. To turn off the built-in
    emulation, the disk drive must be changed to Off in Disk Drives. This can be done either through the
    drop-down or by clicking the Eject button twice.
  </p>


  <h2>Parallel Bus Interface (PBI)</h2>
  <p>
    A <tt>pbi_device</tt> section enables Parallel Bus Interface (PBI) support. It has two member,
    the required <tt>device_id</tt> for the PBI device, and an optional IRQ enable:
  </p>
  <pre>  PBIDevice pbi_device: {
      device_id: $40,   // required
      has_irq: true     // optional
  };</pre>
  <p>
    Exactly one bit must be set in the device ID, with $01..$80 corresponding to PBI devices 0-7.
    Only one <tt>PBIDevice</tt> object can be defined.
    For the purposes of the custom device, the XE Enhanced Cartridge Interface (ECI) is considered
    as equivalent to the PBI.
  </p>
  <p>
    When enabled, Altirra's built-in PBI disk acceleration hardware uses PBI device 7 (ID $80).
    The Atari OS scans enabled PBI devices from device 0 to 7 ($01 to $80), so ID $01 has the highest
    priority. SpartaDOS X, however, scans PBI devices in reverse order and thus priority.
  </p>
  <h3>Selection support</h3>
  <p>
    When PBI device support is enabled, the host automatically monitors writes to the <tt>$D1FF</tt>
    PBI device selection address and will enable the custom PBI device when the specified device ID
    bit is set. This avoids the need to manually map memory layer over the <tt>$D1xx</tt> page with
    a write mapping over that address and allows it to be multiplexed between multiple PBI devices on
    different IDs. The <tt>pbi_select</tt> and <tt>pbi_deselect</tt> script events
    are dispatched when the PBI device is selected or deselected, allowing script to respond to device
    selection. The host will also automatically deselect any active PBI device when a computer reset
    occurs.
  </p>
  <h3>Auto-PBI memory layers</h3>
  <p>
    Memory layers set to <tt>"auto_pbi": true</tt> are enabled for PBI support: their
    priority in the MMU is raised so they can properly overlay motherboard memory resources and the
    math pack ROM, and they are automatically enabled and disabled when the device is selected or
    deselected. Thus, simple PBI devices can switch in both a firmware ROM over the math pack at
    <tt>$D800-DFFF</tt> and control registers without requiring explicit script actions.
  </p>
  <p>
    Additionally, any auto-PBI layer mapped to within <tt>$D800-DFFF</tt> also automatically disables
    emulation hooks in the math pack ROM when it is active so that they do not interfere with PBI firmware.
  </p>
  <h3>PBI interrupts</h3>
  <p>
    Setting <tt>has_irq: true</tt> enables IRQ support for the PBI device. The <tt>assert_irq()</tt> and
    <tt>negate_irq()</tt> methods are used to request a device IRQ.
  </p>
  <p>
    As with other IRQs, the PBI IRQ is a level-based maskable interrupt and must be held asserted until
    the CPU has a chance to service the interrupt. This is done by calling <tt>assert_irq()</tt> on
    the <tt>PBIDevice</tt> object. Once called, this will continually request a maskable interrupt
    on the CPU until <tt>negate_irq()</tt> is called. This is necessary since the CPU may have IRQs
    masked or may be servicing higher priority IRQs from other devices, and the IRQ must continue to
    be requested until either the CPU gets to the PBI device.
  </p>
  <p>
    Once the device IRQ handler runs, it then <i>acknowledges</i>
    the IRQ by a device-specific method so an IRQ is no longer requested by the device, which in this case
    means a call to <tt>negate_irq()</tt>. As there is no generic way to control or acknowledge device
    IRQs, the device IRQ must be disabled on reset until the handler has initialized and set the device's
    ID bit in the operating system's <tt>PDMSK</tt> variable to enable the device's IRQ handler.
    If the IRQ is asserted too early before interrupt handling is in place, the system will typically
    hang as the CPU is forced to re-run the system IRQ dispatcher without having a way to acknowledge the
    device interrupt. To assist in complying with this, the PBI device IRQ is automatically negated whenever a cold or warm reset occurs.
  </p>
  <p>
    As required by the PBI specification, the device's IRQ status bit is also automatically exposed on
    reads from <tt>$D1FF</tt> when the IRQ is enabled so the operating system can identify the source
    of the PBI interrupt. Only the device's ID bit is driven on the bus,
    so other bits in <tt>$D1FF</tt> will reflect open bus data if not driven by another PBI device in
    the system.
  </p>
  <p>
    Putting it all together, the following is an example of a working PBI interrupt implementation:
  </p>
  <ul>
    <li>$D1F0 [W] enables the device interrupt.</li>
    <li>$D1F1 [W] acknowledges the device interrupt.</li>
    <li>
      The PBI firmware's initialization handler sets the device bit in <tt>PDMSK</tt> to enable
      OS interrupt handling for the device, and then writes <tt>$D1F0</tt> to enable the device
      interrupt.
    </li>
    <li>
      
    </li>
  </ul>

  <h2>Controller ports</h2>
  <p>
    Controller ports are bound by creating objects of type <tt>ControllerPort</tt>:
  </p>
  <pre>  ControllerPort port1: 0;
  ControllerPort port2: 1;</pre>
  <p>
    Each member is the variable name to bind the controller port and the index (0-3). The variable then
    points to an object of type <tt>ControllerPort</tt>, which can be manipulated through script.
  </p>
  <p>
    On XL/XE machines, ports 3 and 4 can be bound but are inactive. Their state is preserved and will
    become active if the machine type is switched to 400/800.
  </p>


  <h2>Video outputs</h2>
  <p>
    Devices with auxiliary video outputs, like 80-column video boards, can be emulated by declaring
    a <tt>VideoOutput</tt> object. This allows the custom device to add an entry to the video output
    list, which when selected displays an image maintained by the custom device.
  </p>
  <h3>Creating the video output</h3>
  <p>
    Defining a <tt>VideoOutput</tt> object automatically creates it and adds it to the list of
    available video outputs. The only required property is <tt>display_name</tt>, which sets the
    name of the video output in the UI.
  </p>
  <pre><![CDATA[  VideoOutput video_output: {
      display_name: "XEP80"
  };]]></pre>
  <p>
    This is sufficient to enable the video output, but it is not very useful as it will simply
    show "no signal". For the video output to actually show something it needs to have an
    <tt>Image</tt> bound to it to provide the image data for the video output:
  </p>
  <pre><![CDATA[  Image frame_buffer: {
      width: 320,
      height: 192
  };
  
  event "init": function {
      video_output.set_image(frame_buffer);
      frame_buffer.clear(0);
  };]]></pre>
  <p>
    The video output will then begin displaying the contents of the bound image each frame.
    Images are full 24-bit RGB and can be as colorful as the host can display.
  </p>
  <p>
    The image object contains several methods for drawing on the image, and any changes
    made to the image are shown when the next refresh occurs, which is either at the end
    of the frame or whenever the displays are redrawn. Multiple framebuffer images can
    also be
    used and the video output rebound to different images on the fly; this can be
    useful to emulate page flipping hardware.
  </p>
  <h3>Drawing the image</h3>
  <p>
    While image does provide a <tt>put_pixel()</tt> method, using it to draw the whole
    image every frame would be absurdly slow and painful. <tt>Image</tt> provides several
    methods to draw on the image, including clear, rectangle fill, and rectangle copies
    (blits).
  </p>
  <p>
    One particular blit that is of interest is a <i>tile map blit</i>, provided by
    <tt>blt_tile_map()</tt>. This is a powerful blit type that uses a tile map to select
    regular sized tile images from a tile source. This can be used to emulate both
    graphical tile and character modes and is much faster than doing an individual blit
    per tile.
  </p>
  <p>
    Multiple <tt>Image</tt> objects can be declared, and off-screen images are useful as
    blit sources. An image can be pre-initialized from the contents of a PNG file. The
    <tt>blt_expand_1()</tt> call is also useful for expanding monochrome bitmap data
    from ROM data into an image object.
  </p>
  <p>
    The image bound to a framebuffer does not need to be redrawn every frame if its
    contents don't need to change. Left alone, an <tt>Image</tt> object will retain its
    image data and display the same on the next frame. Thus, it can be useful to maintain
    a dirty flag indicating when a redraw is needed. The <tt>composite</tt> event on
    a video object is triggered right before a video output is redrawn and is useful for
    deferring redraw work until actually needed, avoiding it entirely if the video output
    is not actually shown or has not changed. A valid strategy is to just maintain the
    contents of video RAM from the emulation bindings and only convert it to a displayable image on
    the composite event if a write has occurred to the video hardware or VRAM since
    the last composite.
  </p>

  <h3>Drawing character displays</h3>
  <p>
    It is common for text mode video hardware to use bit 7 as an inverse video bit, and some
    hardware uses non-ASCII character codes. These can be handled efficiently by pre-transforming
    the character graphics. Inverse video can be supported by copying the character or
    image data from the first 128 characters to the second 128 characters and then inverting
    the graphics for the second half. For a different ordering like INTERNAL, permute the
    characters in the character set to fit the code ordering.
  </p>
  <p>
    Character-mode video hardware, particularly those driven by a CRTC, often implement
    hardware scrolling by adjusting the display start address. This can tricky to emulate
    when it involves wrapping around the VRAM address space since the wrap can occur not
    only between rows but even within a row. This can be handled by manually unwrapping
    the character map into a temporary segment, but this involves a bunch of temporary
    copies.
  </p>
  <p>
    An alternate way to handle this is to pre-unwrap video memory by maintaining two
    copies of it, back-to-back. This can be done simply by adjusting the size of the
    VRAM segment to twice the size of VRAM and writing each byte written to both halves
    of the segment. Wrapping is then supported during blits by seamlessly reading from
    the first copy to the second copy of VRAM within the segment, producing the same
    data as wrapping within a single copy.
  </p>
  
  <h3>Fine-tuning image display</h3>
  <p>
    The stretching filter used to display a video output is unspecified and under user
    control; it may be nearest neighbor (point sampling), bilinear interpolation, or
    a more specialized filter. It's a good idea to use an image resolution that matches
    any pixel replication performed by the hardware. For instance, hardware that displays
    a 160x100 image by doubling each scanline to produce a 200 line high image is best
    displayed as 160x200 or 320x200 to avoid overly blurring the display.
  </p>
  <p>
    It is common for video hardware of the time to display images with non-square pixels,
    and replicting that is important to avoid misrepresenting the hardware and distorting
    the output. Almost no hardware of the time actually displayed completely square pixels,
    although some PAL video outputs were close (within 4%). The <tt>set_par()</tt> method
    on the video output allows the pixel aspect ratio (PAR) to be specified so the video
    output can properly scale the image output. This aspect ratio compensation is accelerated
    with graphics hardware at native display resolution whenever possible and is much faster
    than can be done within an <tt>Image</tt>.
  </p>
  
  <h3>Pass-through</h3>
  <p>
    Some video hardware supports <i>pass-through</i> in that they also have a video input
    and can switch between their own video signal or passing through the input signal.
    This allows software-driven switching between two video outputs through one connector,
    without requiring manual plugging and unplugging. This can be emulated in a custom
    device with <tt>set_pass_through()</tt>, which allows the standard ANTIC+GTIA display
    to appear for the custom display. It should only used for hardware that actually had
    that arrangement, however, as otherwise forcing pass-through could preclude the sometimes
    useful and real scenario of dual monitors on dual video outputs.
  </p>
  
  <h3>Activity detection</h3>
  <p>
    For better usability with a single host display, video outputs have provision for
    <i>activity detection</i>. This allows the emulator to start with the video output
    for boot and then automatically switch to an alternate video output when it is initialized
    and starts to be used. Activity-based switching is optional under user control.
  </p>
  <p>
    The mechanism for activity detection is simple: <tt>mark_active()</tt> is called on
    the video output whenever activity is detected, usually a non-trivial write to the
    video hardware. It only needs to be called whenever a switch might need to occur,
    with once per frame in <tt>composite</tt> being a good time.
  </p>
  <p>
    <tt>mark_active()</tt> is designed to be fast in case it is called many times in a
    row, but it's still a good idea to be careful about insertion points and use dirty
    flags to minimize calls. For instance, with a video port that has both address and
    data registers and requires a write to both ports to change a byte in VRAM, it is
    sufficient to instrument only the data write port and not the address port.
  </p>
  
  <h3>Supporting text copy</h3>
  <p>
    For video outputs that display text, a custom device can also support copying
    text from the video output to the clipboard. This is done by supplying a mapping
    from the video output image to a character grid and an ATASCII text backing store
    for the grid. This then allows drag selection over the video output image and
    copy-to-clipboard operations.
  </p>
  <p>
    The mapping from positions in the video output image to character cells is supplied
    with <tt>set_text_area()</tt>, which sets the size of the character grid in
    columns and rows. This is used only to map drag positions to character cell
    positions and to draw a selection highlight; it does not automatically render
    characters into the video output. The text area mapping can be changed on
    the fly, including setting it to 0x0 for graphical modes that have no text.
  </p>
  <p>
    The actual text to copy is set by <tt>set_copy_text_source()</tt>, which
    maps character cells in the text area to ATASCII bytes in a segment buffer.
    For some video hardware, this can map directly to the raw VRAM which already
    holds ASCII or ATASCII character codes. Otherwise, the <tt>pre_copy</tt>
    event allows script to generate an ATASCII representation of the framebuffer
    on the fly only when it is needed.
  </p>
  
  <h2>Scripting</h2>
  <p>
    Custom device behaviors are driven through scripts. These are small fragments
    of code that can maintain state in the custom device and alter its behavior,
    such as by altering memory layers. The scripts are written in a C-like
    language and compiled to bytecode. Thus, they are a bit slower than native
    code, but much faster than using the network server.
  </p>
  <p>
    Example:
  </p>
  <pre><![CDATA[
    if (bank_a != $value) {
        bank_a = $value;

        window_a.set_offset(bank_a << 14);
    }
  ]]></pre>

  <h3>Global variables</h3>
  <p>
    As noted earlier, global variables are declared at top-level scope with type followed by
    variable name: 
  </p>
  <pre>  int r0;</pre>
  <p>
    Variables of type <tt>int</tt> are read/write and can be changed by script. They always default
    to zero when the device is created, but are <i>not</i> automatically cleared afterward; script
    must explicitly reset their values if desired on a cold reset.
  </p>
  <p>
    Object variables, such as ones of type <tt>SIODevice</tt> or <tt>Thread</tt>, are read-only and
    are permanently bound to a unique object instance on creation. They cannot be reassigned to
    point to a different object instance, and are never null.
  </p>

  <h3>Special variables</h3>
  <p>
    Variables prefixed with <tt>$</tt> are special read-only variables provided
    by the host, containing special values of use to the script related to the
    emulated computer or the request that the script is being run for.
  </p>
  <dl>
    <dt>$address</dt>
    <dd>
      Contains the access memory address or memory read or write scripts.
    </dd>

    <dt>$value</dt>
    <dd>
      Contains the byte value being written for memory write scripts.
    </dd>

    <dt>$timestamp</dt>
    <dd>
      Contains the current machine clock cycle, counting up at 1.77/1.79MHz. The
      absolute value of this counter has no meaning, only differences between values.
      This measures emulation time, which measures clock cycles run by the CPU or
      chipset logic; it diverges from real-time whenever the emulator is paused or
      running in turbo mode.
    </dd>
    <dd>
      Emulation time is monotonic and counts forward even if a save state is loaded or
      a reset occurs. However, because the timestamp variable is 32-bit, it is negative half the time and wraps
      every 40 minutes of emulated time. Timestamp calculations must take wrapping into
      account. For instance, <tt>$timestamp &gt; last_time</tt> is unsafe and should
      be replaced with <tt>$timestamp - last_time &gt; 0</tt>. The emulator deliberately
      starts the timestamp counter at a value other than 0 to expose timestamp handling issues.
    </dd>

    <dt>$device</dt>
    <dd>
      For an SIO command handler, contains the device ID of the SIO command (first byte).
    </dd>

    <dt>$command</dt>
    <dd>
      For an SIO command handler, contains the command ID of the SIO command (second byte).
    </dd>

    <dt>$aux1</dt>
    <dd>
      For an SIO command handler, contains the first argument byte of the SIO command (third byte).
    </dd>

    <dt>$aux2</dt>
    <dd>
      For an SIO command handler, contains the second argument byte of the SIO command (fourth byte).
    </dd>

    <dt>$aux</dt>
    <dd>
      For an SIO command handler, contains the argument bytes of the SIO command combined into a single 16-bit
      value. This is equivalent to <tt>$aux1 + 256*$aux2</tt>.
    </dd>
  </dl>

  <h3>Local variables</h3>
  <p>
    A variable declaration inside of a function or script is a local variable, which exists only during
    execution of that function or script. It is declared the same way as a variable, with the type followed
    by one or more variable names:
  </p>
  <pre>  int local_var1, local_var2;</pre>
  <p>
    Local variables must be defined before they are used, and are only valid within the scope in which they
    are defined:
  </p>
  <pre>  {
    int x;

    x = 1;

    {
      int y;
      y = 2;
    }

    y = 3;    // error, y not defined in this scope
  }</pre>
  <p>
    To ensure consistent behavior, local variables are always initialized to zero at the beginning of the
    function. This ensures that random data is never used. However, it does not guarantee that the variable
    is zero when declared within a loop, so relying on the initial value of a variable is not recommended.
  </p>
  <p>
    Each invocation of a script function has a unique set of local variables. This is true either in the case
    of recursion -- a function calling itself either directly or indirectly -- or through execution on multiple
    threads, like a common function used from both an SIO command handler and a memory access handler.
  </p>

  <h3>Expressions</h3>
  <p>
    Expressions are similar to the C language, consisting of the following
    operators, from highest to lowest precedence:
  </p>
  <pre><![CDATA[
   Postfix          .               (dereference)
   Unary            +, -, ~, !      (unary plus/minus, bitwise/logical inversion)
   Multiplicative   *, /, %         (multiply, divide, remainder)
   Additive         +, -            (add, subtract)
   Shift            <<, >>          (arithmetic left/right shift)
   Bitwise AND      &               (bitwise AND)
   Bitwise XOR      ^               (bitwise XOR)
   Bitwise OR       |               (bitwise OR)
   Relational       <, <=, >, >=    (less [equal] and greater [equal])
   Equality         ==, !=          (equal, not equal)
   Logical AND      &&              (short-circuited AND)
   Logical OR       ||              (short-circuited OR)
   Assignment       =               (assignment to variable)
]]></pre>
  <p>
    All operators work with 32-bit signed two's complement integer arithmetic.
    As in C, operations that take boolean inputs treat non-zero values as
    'true' and those that return boolean results give 0 for false and 1 for
    true.
  </p>
  <p>
    The logical AND (<tt>&amp;&amp;</tt>) and logical OR (<tt>||</tt>)
    operators are short-circuiting and will evaluate their right-hand operand
    only if the result is not already determined by the left-hand operand.
    This has functional consequences for a function or method call on the
    right side.
  </p>
  <p>
    There are some differences from C:
  </p>
  <ul>
    <li>
      Hexadecimal numbers are specified with $ instead of 0x prefix.
    </li>
    <li>
      There is no octal.
    </li>
    <li>
      Signed overflow is defined as wrapping in 32-bit.
    </li>
    <li>
      Division/remainder by 0 gives 0, and -$80000000/-1 = -$80000000. No
      exception is raised.
    </li>
    <li>
      The shift operators mask their shift counts by 31.
    </li>
    <li>
      Assignment does not return a value (result is void type).
    </li>
    <li>
      There are no increment/decrement or assignment arithmetic operators.
    </li>
    <li>
      There is no floating point or unsigned math.
    </li>
  </ul>
  <p>
    The keywords 'true' and 'false' are also provided for readability in
    boolean logic. They evaluate to the integers 1 and 0, respectively.
  </p>
  <h3>Statements</h3>
  <p>
    A function body consists of a sequence of statements, which can be one of:
  </p>
  <ul>
    <li>A local variable declaration.</li>
    <li>An expression, which may include an assignment or a method/function call.</li>
    <li>An if statement.</li>
    <li>A return statement.</li>
    <li>A loop statement.</li>
    <li>A block of statements, contained in braces { ... }.</li>
  </ul>
  <p>
    In all cases except for a block, the statement ends in a semicolon.
    Statements may be freely split across lines and indentation is ignored
    by the compiler.
  </p>
  <p>
    Note that a block does not end in a semicolon, and adding one will
    result in a syntax error (doing this results in two statements in C,
    typically with unfortunate consequences).
  </p>
  <h3>Returning values</h3>
  <p>
    Calls to script to request a value, mainly memory read accesses, require
    the script to return a value. This is done with the return statement:
  </p>
  <pre><![CDATA[
  return x + 1;
  return $FF;
]]></pre>
  <p>
    Execution of the function or script ends when the return statement is
    executed and all code after it is skipped.
  </p>
  <p>
    Some scripts are required to return a value, such as those called for
    a memory read access. This is enforced by the compiler, which checks that
    all branch paths through the code end in a return. If one does not, such
    as a return only inside of an if(), the script compiler will throw an error.
  </p>
  <p>
    Scripts that don't need to return a value, such as memory write handlers,
    have "void" return type and don't need a return statement. A return can still
    be used with no argument, however, to end the script early:
  </p>
  <pre>return;</pre>

  <h3>Branching</h3>
  <p>
    The 'if' statement is used to conditionally execute some statements:
  </p>

  <pre><![CDATA[
  if ($timestamp & 1)
    counter = counter + 1;
]]></pre>

  <p>
    The expression after the if keyword is the condition, and the statement
    after the condition is the controlled statement, executed only if the
    condition is non-zero. The controlled statement may be a block, which is
    required if more than one statement is to be controlled:
  </p>

  <pre><![CDATA[
  if ($timestamp & 1) {
    counter = counter + 1;
    counter2 = counter2 + 3;
  }
]]></pre>
  <p>
    An 'else' clause may also be used, which is executed only if the
    condition is false:
  </p>
  <pre><![CDATA[
  if ($timestamp & 1)
    counter = counter + 1;
  else
    counter = counter - 1;
]]></pre>

  <h3>Looping</h3>
  <p>
    The <tt>loop</tt> statement creates an infinite loop, which runs its
    controlled statement over and over:
  </p>
  <pre>  loop {
      Thread.sleep(100);
      counter = counter + 1;
  }</pre>
  <p>
    This is most often used in threads to run a background process. Generally,
    a loop must have a <tt>return</tt> statement or a yielding method call;
    otherwise, the loop would run infinitely without ending or pausing. The
    virtual machine guards against this and will force a script to terminate
    if it takes too long and would hang the emulator.
  </p>
  <p>
    A <tt>while</tt> loop executes its controlled statement as long as the
    while condition is true:
  </p>
  <pre>  while (i &lt; 128) {
      seg.write_byte(i, i);
      i = i + 1;
  }</pre>
  <p>
    The loop condition is tested before the loop begins and each time the
    loop restarts. It is not tested while the loop body executes. If the
    loop condition is false at the beginning of the loop, the whole while
    loop is skipped without being executed once.
  </p>
  <p>
    A <tt>do...while</tt> loop repeats its controlled statement as long
    as the while condition is true:
  </p>
  <pre>  do {
      seg.write_byte(i, i);
      i = i + 1;
  } while (i &lt; 128);</pre>
  <p>
    The loop condition is only checked at the end of each loop, so unlike a
    while loop, the body of a do-while loop always runs at least once.
  </p>
  <p>
    Finally, the <tt>break</tt> statement allows for early exit from the
    a loop, continuing execution after the loop:
  </p>
  <pre>  loop {
      if (seg.read_byte(i) &gt;= 128)
          break;
          
      seg.write_byte(i, 0);
      i = i + 1;
  }</pre>
  <p>
    If a break occurs within nested loops, only the innermost loop is exited.
    Using a <tt>break</tt> statement outside of a loop is an error.
  </p>

  <h3>Conditional compilation</h3>
  <p>
    In some cases, the same script can be reused for two similar but slightly
    different scenarios. Conditional compilation allows an inline script
    to be specialized for the different scenarios without requiring duplication
    of the script or a costly runtime branch. This is used for memory read
    handlers to allow the same script to handle debug and non-debug reads,
    suppressing side effects for the debug read case.
  </p>
  <p>
    A statement is conditionally compiled by prefixing it with an attribute
    consisting of a conditional name within square brackets, optionally
    prefixed by ! for inversion:
  </p>
  <pre>  [!debug_read] layer.set_modes(0, 0);

  [debug]
  if (condition)
      Debug.log("condition false");
  else
      Debug.log("condition true");</pre>
  <p>
    The <tt>[debug]</tt> attribute is used to guard code that should only be enabled
    for debugging. Code marked with it is compiled out unless the <tt>debug</tt>
    option is enabled:
  </p>
  <pre><![CDATA[  option "debug": true;
  
  [debug]
  Debug.log("condition hit");]]></pre>
  <p>
    The <tt>[debug_read]</tt> attribute only includes the next statement for a debug read,
    while the <tt>[!debug_read]</tt> attribute only includes it for a non-debug read. For
    a <tt>loop</tt> statement, this includes the body of the loop, and for an <tt>if</tt>
    statement, this includes the controlled statement along with any associated <tt>else</tt>
    clause. The conditional statement can also be a block:
  </p>
  <pre><![CDATA[  [!debug] {
      wina.set_offset(($address & 7) << 13);
      wina.set_modes(1, 1);
  }]]></pre>
  <p>
    The conditional attribute does not introduce a new scope, so variable declarations
    can be conditionally compiled with the declared variable visible to later code:
  </p>
  <pre>  [!debug] int prev_value = value;

  int v = read_state();

  [!debug]
  if (value != prev_value)
      update();

  return v;</pre>

  <h3>Functions</h3>
  <p>
    Functions can be declared to group common logic for reuse in multiple
    scripts. This must be done from a script include. The syntax is as
    follows:
  </p>
  <pre><![CDATA[
  'function' return-type function-name() {
    ...function-body...
  }
]]></pre>
  <p>
    For example:
  </p>
  <pre><![CDATA[
  function void update_bank() {
    bank = bank + 1;
  }
]]></pre>
  <p>
    Scripts specified in-line in event handlers in the .atdevice file
    are actually just anonymous functions where the function return
    type is implicit and only the function body is given.
  </p>

  <h3>Calling functions</h3>
  <p>
    A function is called by specifying its name, followed by an empty
    set of parentheses after it:
  </p>
  <pre>  update_bank();</pre>
  <p>
    When the function returns a value, it can also be used inside of an
    expression:
  </p>
  <pre>  bank = get_last_bank() + 1;</pre>
  <p>
    Functions can call other functions, but if a recursion loop occurs the function
    call chain will be truncated to prevent a crash.
  </p>
  <p>
    A function must be declared before it can be called, so calling a function
    that appears later in the source code won't work. This can be worked around
    by <i>declaring</i> the function first, which specifies its name and types
    without the function body, which can be provided later. This is done with
    the same syntax as a function definition, just ending after the argument
    parentheses instead of following with the function body:
  </p>
  <pre>  Thread thread_a;
  Thread thread_b;
  
  function void threadfn_b();

  function void threadfn_a() {
      loop {
        thread_b.run(threadfn_b);
        thread_b.join();
      }
  }
  
  function void threadfn_b() {
      int i = 0;
      while (i &lt; 10) {
          Debug.log_int("i = ", i);
          Thread.sleep(500);
      }
  }</pre>

  <h3>Calling methods</h3>
  <p>
    Host-provided objects such as segments and memory layers have <i>methods</i>
    associated with them that can be called to query or modify the object.
    These are called methods instead of functions because they are called in the
    context of an object. The syntax is similar to a function call, except that
    the name is specified after the object with a dot:
  </p>

  <pre><![CDATA[
  object-expr '.' method-name '(' [arg [, arg...]] ')'
]]></pre>

  <p>
    For instance, memory layers have a set_offset() method to change the
    segment offset of a direct-mapped layer. It takes one integer argument,
    the new starting byte offset. Thus, it can be called on a layer object
    called window_a as follows:
  </p>

  <pre><![CDATA[
  window_a.set_offset($4000);
]]></pre>

  <p>
    Some classes also have <i>static methods</i>, which are called wtihin the
    context of the class and don't need an object instance. For these, the
    class name is specified before the dot instead of an object expression:
  </p>
  <pre>  Thread.sleep(100);</pre>

  <h3>Threading</h3>
  <p>
    Script threads can be created to emulate parallel processes. A thread
    is simply declared as a variable of class type <tt>Thread</tt>:
  </p>
  <pre>  Thread cmd_thread, monitor_thread;</pre>
  <p>
    A script thread is used by calling the <tt>run()</tt> method on the thread
    object with the name of a function to run on the thread. This function
    must have a return type of <tt>void</tt> with no arguments. Note that
    no <tt>()</tt> is used after the name of the function, as the function is
    meant to be passed to <tt>run()</tt> instead of being executed immediately.
  </p>
  <pre>  cmd_thread.run(cmd_handler);</pre>
  <p>
    Threads are cooperatively scheduled with no preemption, meaning that only one thread
    is running at a time until either it completes execution of the top-level
    function that was passed to <tt>run()</tt> or it is suspended in a method
    call. Between those points, script execution on the currently running
    thread is atomic: no other script threads run and no emulation time passes.
    Thus, locking primitives are generally not necessary for shared mutable
    data between threads.
  </p>
  <p>
    Script threads are not OS-level threads and are relatively cheap; creating
    several threads that spend the majority of the time waiting on events is
    fine. Polling with threads in tight <tt>Thread.sleep()</tt> loops, however,
    is very bad for emulator performance and to be avoided, especially since
    script performance is lower than native code. For instance, a clock
    cycle counter is much more efficiently updated at read with <tt>$timestamp</tt>
    than by using a thread to continuously maintain it.
  </p>

  <h3>Scripted events</h3>
  <p>
    Certain global events are exposed by the emulator and can have scripts
    attached to them. These are bound using the <tt>event</tt> statement:
  </p>
  <pre>  event "cold_reset": function {
      bank = 0;
  };</pre>
  <p>
    Supported events are:
  </p>

  <dl>
    <dt>"init"</dt>
    <dd>
      Called once when the device is instantiated, and never again.
      This is used for one-time initialization, like reformatting data from
      disk.
    </dd>

    <dt>"cold_reset"</dt>
    <dd>
      Called on a power-cycle event for the device. This is normally
      where script does its state initialization. Typically all state should be
      reset here except for state that is supposed to be non-volatile, like
      battery backed up memory. Any volatile segments are reinitialized before
      this script is run.
    </dd>

    <dt>"warm_reset"</dt>
    <dd>
      Called on a System Reset of the computer.
    </dd>

    <dt>"vblank"</dt>
    <dd>
      Called every frame at the start of vertical blank at line 248. Note that
      this event is invoked regardless of whether the vertical blank interrupt
      is enabled.
    </dd>

    <dt>"sio_command_changed"</dt>
    <dd>
      Called whenever the state of the SIO command line changes. Note that this
      is only called when raw SIO is enabled.
    </dd>

    <dt>"sio_motor_changed"</dt>
    <dd>
      Called whenever the state of the SIO motor line changes. Note that this
      is only called when raw SIO is enabled.
    </dd>

    <dt>"sio_received_byte"</dt>
    <dd>
      Called whenever a byte is sent on the SIO bus in with raw SIO enabled.
      This hook has priority over <tt>recv_raw_byte()</tt> calls; the two should
      not be used together.
    </dd>

    <dt>"pbi_select"</dt>
    <dd>
      Called when the declared PBI device is selected.
    </dd>

    <dt>"pbi_deselect"</dt>
    <dd>
      Called when the declared PBI device is deselected.
    </dd>

    <dt>"network_interrupt"</dt>
    <dd>
      Called when a network server sends an interrupt request.
    </dd>
  </dl>

  <h2>Network server</h2>
  <p>
    For the most complex behaviors, the custom device can be linked to an
    external server. This is the slowest method of emulating behavior and can
    affect emulator performance, but permits the most complex behaviors and
    connections to external data and peripherals. The server communication is
    over a local TCP/IP socket and the server may be written in any language.
  </p>
  <p>
    A networked server is enabled with the "network" option:
  </p>
  <pre><![CDATA[  option "network": {
      port: 6502
  };
]]></pre>
  <p>
    "port" specifies the TCP/IP port to use for the server connection, which
    must be from 1024-49151. The emulator attempts to make a connection to
    this port on localhost. Connecting to servers on external hosts is not
    currently supported, due to latency and security issues.
  </p>
  <p>
    When enabled, the emulator connects to the specified server as soon as the
    custom device is instantiated. The server is required; if the connection
    fails or drops, the emulator may continue in degraded state but the custom
    device will not function correctly. Altirra will time out after one second;
    it will attempt to re-establish dropped connections, but the custom device
    state may be inconsistent between the emulation and the server until the
    next cold reset.
  </p>

  <h3>Enabling server actions</h3>
  <p>
    The server is invoked whenever certain simulator events happen or a memory
    layer control binding has an action type of "network". In this case, the
    emulator will send a command to the remote server and wait for it to
    respond with one or more commands for the emulator to perform to complete
    the action. This is a synchronous process, so the emulator is halted while
    waiting for the server responses and the server should respond as quickly
    as possible. However, except for rare events like system resets, the
    server is only invoked for events pertinent to the custom device.
  </p>
  <p>
    The communications protocol is a binary protocol, with packets exchanged
    in both directions. The details of the protocol are not described here, but
    deviceserver.py script is Python 3 script which handles this protocol.
  </p>
  <p>
    It is permitted for the server to improve throughput by overlapping commands,
    sending a new command before the reply to the previous one has been
    received. All commands are processed sequentially and the replies sent in
    the same order. However, the server must be prepared to receive data for
    earlier commands while in the middle of sending a new command. Otherwise,
    a deadlock may occur with the emulator unable to receive the new command due
    to being blocked on sending the response from the last one.
  </p>
    
  <h3>Events sent to the server</h3>
  <dl>
    <dt>Cold reset</dt>
    <dd>
      The emulated system is powering-on with everything reset except
      for non-volatile storage (memory and registers reset).
    </dd>

    <dt>Warm reset</dt>
    <dd>
      A system reset has occurred through the Reset button on the
      console; memory is preserved and only some registers are reset. Only devices
      intended to be internal devices should respond to this, as external devices
      like SIO peripherals and cartridges do not receive the reset signal.
    </dd>

    <dt>Read/write access</dt>
    <dd>
      A memory read or write has occurred to an address binding
      of network type. The server can issue commands for side effects related to
      the access, such as changes to memory layers. For a read access, the server
      must also respond with the byte value resulting from the read access.
    </dd>

    <dt>Debug read access</dt>
    <dd>
      A memory read access has occurred from the debugger. In
      this case, the server must respond with the same value that a read access
      would have provided, without any associated side effects. In other words,
      the debug read access must not affect the device state in any way.
    </dd>

    <dt>Explicit script call</dt>
    <dd>
      A script uses the <tt>$network</tt> object to get assistance from the remote
      server.
    </dd>
  </dl>

  <h3>Synchronous communication</h3>
  <p>
    Automatically reflected events and messages sent from script are handled
    in synchronous mode: the emulator stops execution and waits for the server
    to handle the event, processing all requests until the final reply from
    the server. These requests can include both querying and changing emulation
    state, such as modifying the contents of memory segments or changing memory
    layers. Processing is ended when the server sends the final reply -- which
    for some cases like memory reads also includes a return value -- and then
    execution resumes. The Request Types section below lists the requests that
    can be issued to the emulator during this processing.
  </p>
  <p>
    Script can manually send messages to the server using the <tt>$network.send_message()</tt>
    method, with two integer parameters. This allows for conditional or custom
    server communication.
  </p>
  <h3>Asynchronous communication</h3>
  <p>
    A downside to synchronous processing is that it lock-steps the emulator while
    it waits for the round-trip through the network stack and for the server
    to respond. Since emulation timing requirements are tight, this can slow down
    the emulator if communication is too frequent. Asynchronous communication
    can alleviate this, by allowing messages to be <i>posted</i> to the other
    side without requiring synchronization. For instance, the server can be
    notified that a byte was sent without waiting for a response. This greatly
    reduces the timing requirements and allows for pipelining between the emulator
    and server processes.
  </p>
  <p>
    For messages from the emulator to the server, the <tt>$network.post_message()</tt>
    method is used instead of <tt>send_message</tt>. This is a fire-and-forget
    call that does not wait for a response and does not return a value. In the other
    direction, <tt>req_interrupt()</tt> from Python invokes the script bound to
    the <tt>network_interrupt</tt> event. Both calls are naturally pipelined in
    the socket buffers, so it is up to script and the network server to implement
    a common protocol if throttling is required.
  </p>
  <p>
    The server may send any type of request to the emulator at any time, not just
    interrupts. The emulator services these at periodic intervals, typically within
    a frame (16-20ms in emulation time), but neither precise timing nor atomicity
    is guaranteed; two requests issued in quick succession outside of a sent message
    handling may execute on different ticks. However, requests are always processed
    in order.
  </p>
  
  <h3>Restrictions on script interrupts</h3>
  <p>
    Script interrupts are executed on a separate script thread and may execute
    suspendable methods, such as <tt>send_raw_byte</tt>. However, if another script
    interrupt arrives during this time, it will abort handling of the previous interrupt to
    service the new one.
  </p>
  <p>
    Executing calls from the script interrupt thread that require synchronous messages
    to the server is possible but discouraged, for a couple of reasons. The first
    is that it can result in undesirable request reordering:
  </p>
  <ul>
    <li>Server sends interrupt A</li>
    <li>Server sends request R</li>
    <li>Emulator begins processing interrupt A</li>
    <li>Emulator sends message to server</li>
    <li>Server issues request Ar and ends processing</li>
    <li>Emulator receives and executes request R</li>
    <li>Emulator receives and executes Ar</li>
  </ul>
  <p>
    In-order request processing and the network stream connection require that request
    R be received and handled by the emulator before request Ar associated with
    interrupt A. This is best avoided by performing the necessary actions within the
    script itself, which allows them to execute before other queued requests from
    the server.
  </p>
  <p>
    The second issue is script interrupt recursion. When the script interrupt thread
    sends a message to the server, it must execute any previously asynchronously
    queued requests from the server to process the replies to the sent message. If any
    of those previously queued messages is a script interrupt, those interrupts will
    be dropped.
  </p>

  <h3>Request types</h3>
  <p>
    The supported request types:
  </p>
  <dl>
    <dt>req_enable_layer</dt>
    <dd>
      Changes the mode of a memory layer to respond or not
      respond to reads and writes.
    </dd>

    <dt>req_set_layer_offset</dt>
    <dd>
      Changes the starting offset of a memory layer within
      its source segment. The segment must be direct map type and the new range
      must be contained within the segment. The contents of the segment are not
      changed.
    </dd>

    <dt>req_set_layer_segment_and_offset</dt>
    <dd>
      Changes both the source segment and the
      starting offset of a memory layer. The segment must be direct map type and
      the new range must be contained within the new segment. The contents of
      the segments are not changed.
    </dd>

    <dt>req_set_layer_readonly</dt>
    <dd>
      Changes whether a memory layer is read-only, i.e.
      blocks but does not respond to writes.
    </dd>

    <dt>req_read_seg_mem</dt>
    <dd>
      Reads data from a range in a segment. The range must be
      entirely contained within the segment.
    </dd>

    <dt>req_write_seg_mem</dt>
    <dd>
      Writes data to a range in a segment. The range must be
      entirely contained within the segment. Any direct-mapped layers mapping
      this segment will immediately reflect the new contents.
    </dd>

    <dt>req_copy_seg_mem</dt>
    <dd>
      Copies data from a range in a source segment to a range
      in a destination segment. This is much faster than doing segment reads and
      writes as it avoids sending the data across to the server. Copying between
      overlapping ranges in the same segment is allowed, in which case the copy
      direction is chosen to avoid corruption (similar to memmove() in C).
    </dd>

    <dt>req_interrupt</dt>
    <dd>
      Requests an interrupt to be delivered to script code, invoking the script
      handler for the <tt>network_interrupt</tt> event.
    </dd>
  </dl>

  <h2>Sample device descriptions</h2>
  <h3>8K cartridge</h3>
  <p>
    The following is a device description that implements a simple 8K cartridge
    designed to be inserted into the left slot of an 800. It loads a predefined
    image from a file and maps it to a hardcoded, read-only mapping at $A000-BFFF.
    This mapping is set as cartridge-enabled so that it is detected by the OS
    on XL/XE systems.
  </p>

  <pre><![CDATA[  option "name": "Sample 8K cartridge";

  Segment flash: {
      size: 8192,
      source: "cart.bin"
  };

  MemoryLayer wina: {
      name: "Left cartridge window",
      address: $A000,
      size: $2000,
      segment: {
        source: flash,
        offset: 0,
        mode: "ro"
      },
      cart_mode: "left"
  };]]></pre>

  <h3>Single-density disk drive</h3>
  <p>
    This device implements a single-density disk drive similar to the Atari 810.
    The ATR disk image is pre-loaded into a segment, and another segment is used
    to hold a predefined status response. The Status command simply sends
    the status segment; the Read and Write commands validate the sector number
    before transferring to or from the disk segment. The Write command is
    a mirror of the Put command.
  </p>
  <p>
    Note that writes to this device are ephemeral and are not written back to
    the image file.
  </p>

  <pre><![CDATA[  option "name": "Sample disk drive device";

  Segment disk: {
      source: "disk.atr",
      source_offset: 16,
      size: 92160
  };

  Segment status: {
      size: 4,
      init_pattern: [ 0, 0, 224, 0 ]
  };

  SIODevice disk_device: {
      device_id: $31,
      commands: [
        {
          id: $50,
          script: function {
            if ($aux <= 0 || $aux > 720)
                $sio.nak();
            else {
                $sio.ack();
                $sio.recv_frame(128);
                disk.copy(($aux - 1)*128, $sio_frame, 0, 128);
                $sio.complete();
            }
          }
        },
        {
          id: $52,
          script: function {
            if ($aux <= 0 || $aux > 720)
                $sio.nak();
            else {
                $sio.ack();
                $sio.complete();
                $sio.send_frame(disk, ($aux - 1)*128, 128);
            }
          }
        },
        {
          id: $53,
          auto_transfer: {
            mode: "read",
            segment: status,
            offset: 0,
            length: 4
          }
        },
        {
          id: $57, copy_from: $50
        }
      ]
  };]]></pre>
  <h2>Changes</h2>
  <dl>
    <dt>v0.5</dt>
    <dd>
      <ul>
        <li>Added <tt>priority</tt> member to memory layers.</li>
      </ul>
    </dd>
    
    <dt>v0.4</dt>
    <dd>
      <ul>
        <li>Added <tt>Image</tt> and <tt>VideoOutput</tt> classes.</li>
      </ul>
    </dd>

    <dt>v0.3</dt>
    <dd>
      <ul>
        <li>JSON format replaced with common script-based format.</li>
        <li>Added conditional compilation.</li>
      </ul>
    </dd>

    <dt>v0.2</dt>
    <dd>
      <ul>
        <li><tt>cctl_mode</tt> can now be <tt>auto</tt>.</li>
        <li><tt>offset</tt> is now optional for SIO auto transfers.</li>
        <li><tt>controller_ports</tt> added.</li>
        <li><tt>vblank</tt> script event added.</li>
      </ul>
    </dd>
  </dl>

</topic>