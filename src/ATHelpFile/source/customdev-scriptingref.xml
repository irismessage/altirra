<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="index.xsl" ?>
<topic title="Custom device specification: scripting reference">
  <toc/>

  <h2>Scripting method reference</h2>
  <p>
    All methods are described in terms of C prototypes for recognizability, even
    though the scripting language does not use such syntax. Argument types should
    be omitted and the names do not have to be used. For instance, for a method
    with the following prototype:
  </p>
  <pre>  void copy_from(int offset, Segment *arg2);</pre>
  <p>
    It could be called as follows:
  </p>
  <pre>  segment1.copy_from(0, segment2);</pre>
  <p>
    A <tt>static</tt> method is one that is called with the class name instead of
    an object instance:
  </p>
  <pre>  Thread.sleep(100);</pre>

  <h3>Segments</h3>
  <p>
    A segment is effectively a byte array, with some additional considerations
    for efficient memory mapping into the emulation and auto-init/reset
    capabilities. Block memory operations are provided for more efficient
    manipulation than would be possible in script a byte at a time.
  </p>
  
  <dl class="scripting-ref">
    <dt>void clear(int value);</dt>
    <dd>
      Clears the entire segment segment with the given byte value.
    </dd>

    <dt>void fill(int offset, int value, int size);</dt>
    <dd>
      Fills a portion of a segment with the given starting byte offset, byte
      value, and number of bytes to fill. The range to fill must be fully
      contained within the segment.
    </dd>

    <dt>void xor_const(int offset, int value, int size);</dt>
    <dd>
      XORs a constant byte value into all bytes within the specified region,
      starting at <tt>offset</tt> and with a length of <tt>size</tt> bytes.
      The range must be fully contained within the segment.
    </dd>
    <dd>
      A value of <tt>$00</tt>
      is a no-op; a value of <tt>$FF</tt> inverts all bits within the range.
    </dd>

    <dt>void reverse_bits(int offset, int size);</dt>
    <dd>
      Reverse the order of bits in each byte within the specified region,
      starting at <tt>offset</tt> and with a length of <tt>size</tt> bytes.
      The range must be fully contained within the segment.      
    </dd>
    <dd>
      A reverse-bits operation swaps bits 0 and 7, bits 1 and 6, bits 2 and 5,
      and bits 3 and 4. One used for a revbits operation is to display bitmap
      data that uses LSB-to-MSB order instead of the MSB-to-LSB order used
      by ANTIC.
    </dd>
    
    <dt>void copy(int dest_offset, Segment *src_segment, int src_offset, int size);</dt>
    <dd>
      Copies a range from a source segment to this segment, given starting
      byte offsets in both segments and the number of bytes to copy. The
      source and destination ranges must be fully contained within the
      respective segments. size=0 is silently ignored.
    </dd>
    <dd>
      The source and destination segments can be the same. If the copy ranges
      overlap, the copy direction is selected to preserve the contents of the
      copied range at the new location (memmove semantics).
    </dd>
    <dd>
      Copying large amounts of data with copy() is slow and should not be used
      to implement memory banking. Changing the offset of a memory layer is
      faster.
    </dd>
    
    <dt>void copy_rect(int dest_offset, int dest_skip, Segment *src_segment, int src_offset, int src_skip, int width, int height);</dt>
    <dd>
      Copies a rectangular range of bytes from a source segment to this segment.
      The destination region is specified as <tt>dest_offset</tt>, the offset
      of the top-left byte, and <tt>dest_skip</tt>, the number of bytes between
      the end of one row and the start of the next. The source region is similarly
      specified by <tt>src_offset</tt> and <tt>src_skip</tt>.
    </dd>
    <dd>
      <tt>width</tt> and <tt>height</tt> specify the size of the region to be
      copied, such that each row is a contiguous range of <tt>width</tt> bytes
      with <tt>height</tt> rows. The region to be copied must be entirely
      contained in both the source and the destination. A copy rect operation
      of width or height 0 is allowed as a no-op.
    </dd>
    <dd>
      The source and destination segments may also be the same. If the source
      and destination rects overlap -- that is, they contain one or more common
      bytes -- then the skip values must be the same. In that case, the copy
      direction is chosen as needed to preserve the contents of the region,
      allowing for in-place scrolling. If the regions do not actually overlap,
      such as one rect tucked into the padding gaps of the other, the skip
      values may be different.
    </dd>

    <dt>void translate(int dest_offset, Segment *src_segment, int src_offset, int size, Segment *table_segment, int table_offset);</dt>
    <dd>
      Copies a region from one segment to another, translating each byte through
      a translation table. The destination region starts at <tt>dest_offset</tt>
      in the called segment and the source region starts at <tt>src_offset</tt>
      in <tt>src_segment</tt>, both extending for
      <tt>size</tt> bytes. The translation table starts at <tt>table_offset</tt>
      in <tt>table_segment</tt> and is 256 bytes long, each byte containing the
      new value for the corresponding original byte value in the source.
    </dd>
    <dd>
      All regions must fit completely within their segments.
      The source and destination regions may be in the same segment, but may
      not overlap unless the regions are exactly the same (in-place). The
      translation table must not overlap the destination region.
    </dd>
    
    
    <dt>int read_byte(int offset);</dt>
    <dd>
      Reads the byte at the given offset within the segment, as value 0-255.
      The offset must be within the segment.
    </dd>

    <dt>void write_byte(int offset, int value);</dt>
    <dd>
      Writes a byte value at the given offset within the segment. The byte
      value to be written is 0-255, but other values may be given, in which
      case the lowest 8 bits are used.
    </dd>

    <dt>int read_word(int offset);</dt>
    <dd>
      Reads the 16-bit word at the given starting offset, with the LSB at the
      given offset and the MSB in the next byte. The word is returned as
      a value 0-65535.
    </dd>

    <dt>void write_word(int offset, int value);</dt>
    <dd>
      Writes a 16-bit word to the given starting offset, with the LSB at the
      given offset and the MSB in the next byte. If the value is outside of
      0-65535, the lowest 16 bits are used.
    </dd>

      <dt>int read_rev_word(int offset);</dt>
    <dd>
      Reads the 16-bit big endian word at the given starting offset, with
      the MSB at the given offset and the LSB in the next byte. This is reversed
      from the usual 6502 byte ordering. The word is returned as a value 0-65535.
    </dd>

    <dt>void write_rev_word(int offset, int value);</dt>
    <dd>
      Writes a 16-bit big endian word to the given starting offset, with
      the MSB at the given offset and the LSB in the next byte. If the value
      is outside of 0-65535, the lowest 16 bits are used.
    </dd>
</dl>

  <h3>Memory layers</h3>
  <dl class="scripting-ref">
    <dt>void set_offset(int offset);</dt>
    <dd>
      Sets the starting byte offset of a direct-mapped layer within its mapped
      segment. For instance, a value of $2000 for a layer size of $1000 will map
      $2000-3FFF, which requires that the mapped segment be at least $4000 bytes.
      Attempting to call this for a binding-controlled segment or with an invalid
      offset is an error.
    </dd>

    <dt>void set_segment_and_offset(Segment *seg, int offset);</dt>
    <dd>
      Sets both the mapped segment and offset within that segment used by
      a direct-mapped memory layer. The offset must satisfy the requirements
      of <tt>set_offset()</tt> for the new segment.
    </dd>

    <dt>void set_modes(int read_enable, int write_enable);</dt>
    <dd>
      Enables or disables the layer for read or write accesses. For a read-only
      layer, the write enable controls whether the layer blocks write accesses
      to lower layers; it will not enable write accesses into the layer itself.
    </dd>
    <dd>
      For cartridge-enabled or auto-PBI layers, <tt>set_modes()</tt> will not
      enable a layer when the cartridge is disabled or PBI device is deselected.
      However, the desired mode is still changed and will become active when the
      cartridge or PBI device is enabled.
    </dd>
    <dd>
      <b>Bug note</b>: Versions prior to 4.20-test29 ignore auto-PBI when <tt>set_modes()</tt>
      is called.
    </dd>
    
    <dt>void set_read_only(int enabled);</dt>
    <dd>
      Sets or clears the read-only state for a memory layer. A memory layer
      that is read-only and mapped for write access will intercept writes
      from lower memory layers but not change the contents of the backing
      segment. The read-only state has no effect if the memory layer is not
      mapped for write.
    </dd>

    <dt>void set_base_address(int address);</dt>
    <dd>
      Changse the base address of a memory layer. The memory layer must be
      direct mapped to a segment. The address must be page-aligned and the
      new address window must fit within the 64K address space.
    </dd>
  </dl>

  <h3>Network connection</h3>
  <p>
    The network connection is accessed through the <tt>$network</tt> object.
  </p>
  <dl class="scripting-ref">
    <dt>int send_message(int param1, int param2);</dt>
    <dd>
      Sends a message to the network server and waits for an integer response,
      servicing requests from the server during the transaction. The meaning
      of the two parameters and the return value are user-defined and up to
      the server implementation.
    </dd>

    <dt>void post_message(int param1, int param2);</dt>
    <dd>
      Posts a message to the network server without waiting for a response.
      The meaning of the two parameters and the return value are user-defined
      and up to the server implementation.
    </dd>
    <dd>
      This is faster than <tt>send_message</tt> because it does not require
      the emulator to wait for the server.
    </dd>
  </dl>

  <h3>SIO connection</h3>
  <p>
    The serial I/O (SIO) bus is accessed through the <tt>$sio</tt> object.
    The methods on this object are only valid in scripts that are processing
    SIO requests.
  </p>
  <p>
    For methods in this class, "send" and "receive" are from the standpoint
    of the device. A send operation transmits data from the device to the computer,
    and a receive operation transmits data from the computer to the device.
  </p>
  <dl class="scripting-ref">
    <dt>void ack();</dt>
    <dd>
      Send an ACK byte ($41) to the computer. This is used to affirm reception
      of a valid command or data frame.
    </dd>
    <dd>
      There is a built-in delay of 850 &#181;s before the A byte when an ACK is
      sent after a received data frame to ensure that SIO protocol requirements
      are met and the OS can receive the byte properly.
    </dd>

    <dt>void nak();</dt>
    <dd>
      Send an NAK byte ($4E) to the computer. This is used to signal an invalid
      command or a corrupted data frame.
    </dd>
    <dd>
      There is a built-in delay of 850 &#181;s before the N byte when an ACK is
      sent after a received data frame to ensure that SIO protocol requirements
      are met and the OS can receive the byte properly.
    </dd>

    <dt>void error();</dt>
    <dd>
      Send an Error byte ($45) to the computer. This is used to signal completion
      of a failed command.
    </dd>
    <dd>
      There is a built-in delay of 250 &#181;s before the E byte is sent to ensure
      that SIO protocol requirements are met and the OS can receive the byte properly.
    </dd>

    <dt>void complete();</dt>
    <dd>
      Send a Complete byte ($43) to the computer. This is used to signal completion
      of a successful command.
    </dd>
    <dd>
      There is a built-in delay of 250 &#181;s before the C byte is sent to ensure
      that SIO protocol requirements are met and the OS can receive the byte properly.
    </dd>

    <dt>void send_frame(Segment *seg, int offset, int length);</dt>
    <dd>
      Send a data frame to the computer from the given segment, starting at offset
      and with length bytes, not including the checksum. The range must fit within
      the segment. A standard SIO checksum is automatically appended at the end of
      the frame (1's complement of all payload bytes). Script execution is suspended
      until the send completes.
    </dd>
    <dd>
      Data is copied from the segment to an internal buffer as soon as the send request
      is queued, so any modifications to the segment after that are not reflected in
      the transfer. This is possible since memory access handlers can run in parallel
      to SIO transactions.
    </dd>
    <dd>
      There is a limit of 8192 bytes per frame sent.
    </dd>

    <dt>void recv_frame(int length);</dt>
    <dd>
      Receive a data frame from the computer with the given number of bytes, not
      including the checksum. The checksum is automatically checked and if it fails,
      a NAK is automatically sent and command processing is terminated. Script
      execution is suspended until the receive completes.
    </dd>
    <dd>
      When the frame is received, script execution is resumed. The received frame
      is available in a special segment called <tt>$sioframe</tt>. This segment
      is only valid during the current script until it exits or is suspended; if
      the data is required beyond that it should be copied into another segment.
      The <tt>$sioframe</tt> segment is read-only and cannot be mapped into a
      memory layer.
    </dd>
    <dd>
      There is a limit of 8192 bytes per frame received.
    </dd>

    <dt>void delay(int cycles);</dt>
    <dd>
      Suspend execution of the script for the given number of machine cycles.
    </dd>

    <dt>int command_asserted();</dt>
    <dd>
      Returns true if the SIO COMMAND line is asserted, indicating that a command
      frame is being transferred.
    </dd>

    <dt>int motor_asserted();</dt>
    <dd>
      Returns true if the SIO MOTOR line is asserted, meaning that the computer is
      requesting a tape deck to run or a communications device to take control of
      the SIO bus for non command frame based transfers.
    </dd>

    <dt>void enable_raw(int enable);</dt>
    <dd>
      Enables or disables raw SIO. This is needed to send raw bytes, signals on
      the SIO PROCEED or INTERRUPT lines, or to receive raw SIO events. However,
      performance is impacted when this is enabled, so it should only be enabled
      when needed. The default is disabled.
    </dd>
    <dd>
      Disabling raw SIO automatically deasserts the PROCEED and INTERRUPT lines,
      if they have been asserted.
    </dd>

    <dt>void set_proceed(int asserted);</dt>
    <dd>
      Asserts or deasserts the SIO PROCEED control line.
    </dd>
    <dd>
      Raw SIO must be enabled to use this method.
    </dd>

    <dt>void set_interrupt(int asserted);</dt>
    <dd>
      Asserts or deasserts the SIO INTERRUPT control line.
    </dd>
    <dd>
      Raw SIO must be enabled to use this method and it must be called on a script thread.
    </dd>

    <dt>int send_raw_byte(int ch, int cycles_per_bit);</dt>
    <dd>
      Send a raw byte on the SIO bus from the device to the computer's SIO DATA IN
      line.
    </dd>
    <dd>
      ch is the data byte to send, as it will be received in POKEY's SERIN register.
      Start and stop bits are automatically added around this byte, for a total of
      10 bits to transfer.
    </dd>
    <dd>
      While cycles_per_bit is the number of computer machine cycles between each bit.
      A value 93 is used for 19200 baud (19069-19245 baud).
    </dd>
    <dd>
      Raw SIO must be enabled to use this method and it must be called on a script thread.
      Thread execution is suspended until the byte is fully sent.
    </dd>

    <dt>int recv_raw_byte();</dt>
    <dd>
      Wait for a byte to arrive on the SIO bus and return the byte received. The bit rate
      in cycles per bit is stored in the thread-local <tt>$aux</tt> variable.
    </dd>
    <dd>
      Raw SIO must be enabled to use this method and it must be called on a script thread.
    </dd>
    <dd>
      <tt>recv_raw_byte()</tt> will not work if the <tt>sio_received_byte</tt> script
      event is bound.
    </dd>

    <dt>void wait_command();</dt>
    <dd>
      Wait for the SIO command line to assert, signaling the beginning of a command
      frame. Only a leading edge resumes execution; if SIO command is already asserted
      when this method is called, the method waits until the signal is deasserted and
      re-asserted.
    </dd>
    <dd>
      This method is intended for waiting for the beginning of a command frame.
    </dd>
    <dd>
      Raw SIO must be enabled to use this method and it must be called on a script thread.
    </dd>

    <dt>void wait_command_off();</dt>
    <dd>
      Wait for the SIO command line to be deasserted, signaling the not-command-frame
      state. If SIO command is already deasserted when this method is called, execution
      continues immediately.
    </dd>
    <dd>
      This method is intended for waiting until the computer is ready to receive the device
      ACK/NAK response to the command frame.
    </dd>
    <dd>
      Raw SIO must be enabled to use this method and it must be called on a script thread.
    </dd>

    <dt>void wait_motor_changed();</dt>
    <dd>
      Wait for the SIO motor line to change state from the current polarity. The
      <tt>motor_asserted()</tt> method can be used to check the state before or after this
      call.
    </dd>
    <dd>
      Raw SIO must be enabled to use this method and it must be called on a script thread.
    </dd>

    <dt>void reset_recv_checksum();</dt>
    <dd>
      Resets the checksum value accumulator for receive operations to zero.
    </dd>

    <dt>void reset_send_checksum();</dt>
    <dd>
      Resets the checksum value accumulators for send operations to zero.
    </dd>

    <dt>int get_send_checksum();</dt>
    <dd>
      Reads the computed SIO checksum for all bytes sent with raw SIO since the last call to <tt>reset_send_checksum()</tt>.
      This is the 8-bit one's complement sum of all bytes.
    </dd>
    <dd>
      Typically this is called after the payload of a data frame is sent, with the checksum
      computed by this method being sent afterward.
    </dd>

    <dt>int get_recv_checksum();</dt>
    <dd>
      Reads the computed SIO checksum for all bytes received with raw SIO since the last call to <tt>reset_recv_checksum()</tt>.
      This is the 8-bit one's complement sum of all bytes.
    </dd>
    <dd>
      When using this to verify the received checksum for a command or data frame, <tt>get_recv_checksum()</tt>
      should be called before the checksum is received, or else the checksum computation will also include the
      received checksum byte. For instance, when receiving a 128 byte data frame, the sequence would be:
      <tt>reset_recv_checksum()</tt>, 128x <tt>recv_raw_byte()</tt>, <tt>get_recv_checksum()</tt>, <tt>recv_raw_byte()</tt>,
      then compare the computed and received checksum bytes.
    </dd>
    <dd>
      The checksum accumulator is updated whenever a script receives a byte with <tt>recv_raw_byte()</tt>. It is
      not updated if a byte is received when a script is not waiting to receive (thus missing the byte).
    </dd>

    <dt>int check_recv_checksum();</dt>
    <dd>
      Compares the last byte received against the computed SIO checksum for all bytes received with raw SIO since
      the last call to <tt>reset_recv_checksum()</tt>, not including the last byte, and returns true if they
      match. This is a shortcut for saving the result of <tt>get_recv_checksum()</tt> and comparing it after receiving
      the checksum byte, allowing:
    </dd>
    <dd>
      <pre>  $sio.recv_raw_byte();
  if ($sio.check_recv_checksum())
    ...</pre>
    </dd>
  </dl>

  <h3>PBI device</h3>
  <p>
    Declaring an instance of the <tt>PBIDevice</tt> class creates a custom Parallel Bus Interface (PBI) device.
    There can only be one instance.
  </p>
  <dl class="scripting-ref">
    <dt>
      device_id: <i>int</i>
    </dt>
    <dd>
      Required: Sets the device ID for the PBI device. This must be exactly one bit set from bit 0 to bit 7, as a
      power of two from <tt>$01</tt> to <tt>$80</tt>. The lower the device ID, the higher priority the
      PBI device in SIO, CIO, and IRQ handling.
    </dd>

    <dt>
      has_irq: <i>int</i>
    </dt>
    <dd>
      Optional: If true, enables IRQ handling for the PBI device. The device's ID bit is exposed as an IRQ status
      bit in <tt>$D1FF</tt> and the <tt>assert_irq()</tt> and <tt>negate_irq()</tt> methods are enabled.
    </dd>

    <dt>void assert_irq();</dt>
    <dd>
      Asserts the PBI device's interrupt request (/IRQ) signal. This will cause a maskable interrupt on the CPU, the next
      time maskable interrupts are enabled. If the PBI device's IRQ is already asserted, this does nothing.
    </dd>
    <dd>
      The IRQ line stays asserted until either <tt>negate_irq()</tt> is called or a system reset occurs.
    </dd>
    
    <dt>void negate_irq();</dt>
    <dd>
      Negates the PBI device's interrupt request (/IRQ) signal, so that it no longer requests a maskable interrupt
      from the CPU. If the IRQ is already negated, this does nothing.
    </dd>
  </dl>

  <h3>Clock</h3>
  <p>
    The <tt>$clock</tt> object provides methods to access the host real-time clock
    for emulating real-time clock devices.
  </p>
  <dl class="scripting-ref">
    <dt>void capture_local_time();</dt>
    <dd>
      Snapshot the current time in the current local time zone. This captures the local
      time in one pass so that accesses to individual fields are consistent. The local time is cached so
      that the time is not fetched more than once per script; it cannot be used to measure
      execution time within a script.
    </dd>

    <dt>int local_year();</dt>
    <dd>
      Return the year of the last captured local time as a four-digit value, e.g. 2020.
    </dd>

    <dt>int local_month();</dt>
    <dd>
      Return the month of the last captured local time (1-12).
    </dd>

    <dt>int local_day();</dt>
    <dd>
      Return the day of the month of the last captured local time (1-31).
    </dd>

    <dt>int local_dayofweek();</dt>
    <dd>
      Return the day of the week of the last captured local time as a value 0-6, where 0 means Sunday.
    </dd>

    <dt>int local_hour();</dt>
    <dd>
      Return the hour of the last captured local time (0-23).
    </dd>

    <dt>int local_minute();</dt>
    <dd>
      Return the minute of the last captured local time (0-59).
    </dd>

    <dt>int local_second();</dt>
    <dd>
      Return the second of the last captured local time (0-59).
    </dd>
  </dl>

  <h3>Controller ports</h3>
  <p>
    Controller port objects represent one of the 9-pin controller ports on
    the system, bound to a scripting variable with the <tt>controller_ports</tt>
    section.
  </p>
  <p>
    On a computer with only two controller ports (XL/XE), the third and fourth
    controller ports are disabled; they maintain state and all functions can be
    called, but the controller state is not applied to hardware state.
  </p>
  <dl class="scripting-ref">
    <dt>void set_paddle_a(int pos);</dt>
    <dt>void set_paddle_b(int pos);</dt>
    <dd>
      Sets the position of paddle A or paddle B, as the value returned from the
      <tt>POT0-7</tt> register and as reflected by the BASIC <tt>PADDLE()</tt>
      function. The valid range is 1-228; other values are clamped to this range.
    </dd>

    <dt>void set_trigger(int down);</dt>
    <dd>
      Sets the joystick trigger button state, where false means up and true
      means down.
    </dd>

    <dt>void set_dirs(int mask);</dt>
    <dd>
      Sets a bitmask of which joystick direction inputs should be asserted.
      Bits 0-3 correspond to up, down, left, and right, with a '1' bit meaning
      that the direction is active (grounded). This is inverted from the
      state as reflected in the PORTA/PORTB registers or reported by the
      BASIC <tt>STICK()</tt> function. Zero deactivates all inputs (joystick
      centered).
    </dd>
    <dd>
      As on the real hardware, the left and right inputs (bits 2-3) also
      double as the paddle triggers.
    </dd>
    <dd>
      When emulating a joystick, it is the responsibility of the device to not
      send both left+right or up+down to the computer. This is a valid input
      hardware-wise, but generally not possible with joystick hardware and some
      programs that use joysticks will malfunction if this is seen.
    </dd>
  </dl>

  <h3>Debug class</h3>
  <p>
    The <tt>Debug</tt> class contains methods to aid in development of custom
    devices.
  </p>
  <dl class="scripting-ref">
    <dt>static void log(String *s);</dt>
    <dd>
      Prints a string to the CUSTOMDEV logging channel in the debugger.
    </dd>

    <dt>static void log_int(String *s, int value);</dt>
    <dd>
      Prints a string to the CUSTOMDEV logging channel in the debugger, followed
      by an integer value formatted as decimal.
    </dd>
  </dl>

  <h3>Thread class</h3>
  <p>
    The <tt>Thread</tt> class contains methods to control execution of script
    threads. These methods only work with explicitly declared script threads; they
    cannot be used on the implicit threads created for direct script handlers or
    SIO command execution. However, those threads can control script threads.
  </p>
  <p>
    All script threads are <i>cooperatively</i> scheduled on a single thread of
    execution.
  </p>
  <dl class="scripting-ref">
    <dt>int is_running();</dt>
    <dd>
      Returns true if the thread is currently running. This includes being temporarily
      suspended in a method call, or while waiting for its turn to execute (since
      only one thread can execute at a time).
    </dd>

    <dt>int run(function f);</dt>
    <dd>
      Starts execution of the specified function on the given thread. The function must
      return <tt>void</tt>. If the thread is currently running, it is stopped before
      being restarted at the beginning of the given function.
    </dd>
    <dd>
      <tt>run()</tt> cannot be called on the current thread.
    </dd>

    <dt>void interrupt();</dt>
    <dd>
      Stops execution on the thread, interrupting all currently executing functions on
      the thread's stack. For threads stopped in a yielding method, what side effects
      if any occur from the interrupted method call depend on the specific method.
    </dd>
    <dd>
      The currently executing thread cannot interrupt itself.
    </dd>

    <dt>static void sleep(int cycles);</dt>
    <dd>
      Suspends execution of the thread for the specified number of machine cycles (at 1.77/1.79MHz).
      Negative or zero values are silently ignored and do not suspend.
    </dd>
    <dd>
      This method cannot be used in an SIO command handler script, which must use <tt>$sio.delay()</tt>
      instead. The reason for this is that SIO command handling is sequenced through the SIO manager's
      action queue and it may virtualize actions that would ordinarily take time.
    </dd>

    <dt>void join();</dt>
    <dd>
      Join threads of execution by waiting until the given thread finishes. This includes either
      the thread returning from its top-level function or being stopped with <tt>interrupt()</tt>.
    </dd>
    <dd>
      Ordinarily two threads should not <tt>join()</tt> on each other, as this would cause the
      two threads to <i>deadlock</i> by endlessly waiting for each other. This is still allowed,
      however, and the deadlock can be broken by a third thread interrupting one of the two.
    </dd>
    <dd>
      It is guaranteed that <tt>join()</tt> does not return until the thread has become idle, but
      it does not prevent another thread from being scheduled in between and restarting the thread
      before the thread that called <tt>join()</tt> can resume. If more than one thread calls
      <tt>join()</tt> on the same target thread, all waiting threads are resumed when the target
      thread finishes.
    </dd>
  </dl>

  <h3>Image class</h3>
  <p>
    The <tt>Image</tt> class contains a 24-bit writable image bitmap. Images are either created
    new with <tt>width</tt> and <tt>height</tt> in pixels, or loaded from an image file in PNG format
    with the <tt>source</tt> property.
  </p>
  <p>
    Individual images are limited to a max of 65536 pixels in width or height and four million pixels
    (2^22 to be exact). Thus, images of size 8x65536 and 2048x2048 can be used, but not 4096x4096.
  </p>
  <p>
    The image coordinate system is top down with (0,0) being the top-left corner of the image.
    Rectangles are specified as a top-left corner position, width, and height. A rectangle entirely
    outside of the image or with negative width or height is fully clipped and causes the operation
    to be silently dropped (fully clipped). A rectangle partially within the image is partially clipped
    and may or may not be supported by the operation, with some calls still operating on the
    partially clipped area and others dropping the operation.
  </p>
  <p>
    Pixel values in the image API are 24-bit pixels of the form <tt>$rrggbb</tt>, with RGB values
    being conventional 24-bit sRGB values similarly to as seen in HTML and CSS. The highest 8 bits
    of the pixel value (alpha) are ignored on input and zero on output. Images that are created without
    a backing image are initialized with a hot pink color to make obvious when uninitialized image
    data is being used.
  </p>
  <p>
    Image processing occurs on the CPU and can get expensive, so large pixel area operations should
    be used sparingly.
  </p>
  <dl class="scripting-ref">
    <dt>width: <i>int</i><br/>
      height: <i>int</i>
    </dt>
    <dd>
      Optional; specify the width and height when an image is defined, in pixels. Required if <tt>source</tt> is not
      specified.
    </dd>
    
    <dt>source: <i>path</i></dt>
    <dd>
      Required; specifies the path to a PNG file to initialize the image. Required if <tt>width</tt> and
      <tt>height</tt> are not specified.
    </dd>
    
    <dt>void clear(int color);</dt>
    <dd>
      Clears the entire image to a solid color.
    </dd>

    <dt>int get_pixel(int x, int y)</dt>
    <dd>
      Reads the value of a pixel. Locations outside of the image return zero.
    </dd>

    <dt>void put_pixel(int x, int y, int color);</dt>
    <dd>
      Writes a pixel to the image with the specified color. Locations outside of the image are ignored.
    </dd>

    <dt>void fill_rect(int x, int y, int width, int height, int color);</dt>
    <dd>
      Fills a rectangle of the image with the specified color, using (x, y) as the top-left corner of
      the rectangle. Partial clipping is supported.
    </dd>

    <dt>void invert_rect(int x, int y, int width, int height);</dt>
    <dd>
      Converts the pixels within the given rectangle to their inverse, equivalent to the bitwise complement
      of the bits, or reversing the 0-255 range of each channel. Partial clipping is supported.
    </dd>

    <dt>void blt(int dx, int dy, Image *source, int sx, int sy, int width, int height);</dt>
    <dd>
      Performs a <b>bl</b>ock <b>t</b>ransfer of a rectangle from the source image to this image as the
      destination, using (dx, dy) as the top-left corner in the destination and (sx, sy) as the top-left
      corner in the source. No stretching is performed. Partial clipping is supported, copying the largest
      rectangle completely within both the source and the destination images.
    </dd>
    <dd>
      The source and destination images may be the same, and in the case that the source and destination
      rectangles overlap, the copy direction is chosen to preserve the pixels in the source rectangle.
      Thus, a blit operation may be used to scroll a portion of an image.
    </dd>

    <dt>void blt_expand_1(int dx, int dy, Segment *source, int offset, int pitch, int width, int height, int color0, int color1);</dt>
    <dd>
      Expands raw monochrome (1-bit) data in a source segment to pixels in an image. The monochrome data is expected to be
      in MSB-to-LSB bit ordering, the same as expected by ANTIC. 0 bits are expanded to color0 and 1 bits are expanded to color1.
      Partial clipping is not allowed in either source or destination.
    </dd>
    <dd>
      The source data is specified as a pointer to the first row of data, which is the byte containing the top-left pixel,
      and a <i>pitch</i> value, which is the difference from the starting offset of one row to the start of the next.
      For a packed bitmap with no gaps between rows, the pitch is equal to the number of bytes needed per row, rounded up.
      For instance, a 320-wide packed bitmap would have a pitch of 40 bytes. The pitch value may also be negative to flip
      the image vertically or zero to repeat a single row.
    </dd>

    <dt>void blt_tile_map(int x, int y, Image *tile_source, int tile_width, int tile_height, Segment *tile_map_source, int tile_map_start, int tile_map_skip, int tile_map_width, int tile_map_height);</dt>
    <dd>
      Performs a tile map blit, where a tile map in a segment is used to map fixed-size tiles in a tile source image to tiles in the destination image (the image this method is called on).
      This is useful for both character modes and background tiled graphic modes. Partial clipping is not allowed in any of the images or segments.
    </dd>
    <dd>
      The tile map is stored as bytes in a segment, where each byte refers to one of 256 tiles in the tile source image. The tile map
      is stored left-to-right, then top-to-bottom. Thus, a 80x24 tile map requires 1920 bytes. A positive number of bytes can
      be specified to be skipped at the end of each row via <tt>tile_map_skip</tt>, which allows the tile map to be larger than the
      rectangle used for the tile map blit. For instance, a 40x25 region may be used from a 256x256 tile map by setting the skip
      value to 256 - 40 = 216 bytes. A skip value of 0 specifies a packed tile map with no space between rows.
    </dd>
    <dd>
      The tile source is an image with tiles stacked vertically, with tile 0 being at the top of the image and each successive
      tile below it in order. <tt>tile_width</tt> and <tt>tile_height</tt> specify the size of a tile in pixels. The tile source
      must be large enough to store a full set of 256 tiles. A set of 8x8 tiles therefore requires a 8x2048 image. The <tt>init</tt>
      event can be useful to prepare this tile source image from other sources, such as a PNG file containing the tiles stored in
      a more easily editable 16x16 grid, or raw bitmap data in a ROM image.
    </dd>
    <dd>
      (x, y) specifies the top-left corner of the destination area, and <tt>tile_map_width</tt> and <tt>tile_map_height</tt>
      specify the area to be written in tiles.
    </dd>
  </dl>

  <h3>VideoOutput class</h3>
  <p>
    VideoOutput objects are used to create alternate video outputs produced by devices, which can then in turn be displayed. These
    can either be entirely parallel video outputs like the XEP80, or they can have pass-through capability to show either
    a custom video output or the main computer output, like the Bit-3 Full View 80. Image objects supply the pixel content
    to display through a VideoOutput.
  </p>
  <dl class="scripting-ref">
    <dt>
      display_name: <i>string</i>
    </dt>
    <dd>
      Required; provides the user-readable name of the video output in the UI. The video output name should be
      the name of the device or video output without "output" or "video output" in the name; the UI adds this
      as needed.
    </dd>
    
    <dt>
      composite: <i>function</i>
    </dt>
    <dd>
      Optional; invoked before the video output is refreshed to allow the contents of the backing Image to be updated.
      This allows for lazy updates, such as redrawing the contents of the image from a framebuffer in a segment.
      However, it is not necessary to hook this event if the image contents are kept up to date from other scripts.
    </dd>
    <dd>
      Note that the <tt>composite</tt> event is not guaranteed to be dispatched once per frame. It may be dispatched
      more often if the system is stopped in the debugger mid-frame or less often if refreshing is not required. As
      a result, <tt>composite</tt> must not cause observable side effects in the core emulation, such as changing
      CPU-visible registers or memory. Use other mechanisms such as the global <tt>vblank</tt> event or a timer thread
      if a per-frame tick is needed.
    </dd>
    
    <dt>
      pre_copy: <i>function</i>
    </dt>
    <dd>
      Optional; invoked before a copy text operation completes. This gives script a chance to update an ATASCII copy of
      the framebuffer contents and bind it to the video output with <tt>set_copy_text_source()</tt> before the copy
      operation occurs, so those contents don't have to be constantly up to date. Because this is only invoked on copy
      operations, it can perform relatively expensive operations that would be undesirable to run as the framebuffer
      is updated. It can be omitted if those contents are always available, such as a framebuffer that is natively
      ATASCII and in a fixed location.
    </dd>
    
    <dt>void set_par(int numerator, int denominator);</dt>
    <dd>
      Sets the pixel aspect ratio (PAR) for the video output, as a fraction of two integers giving the ratio of width to height.
      This is used to correctly display the video output with non-square pixels when aspect ratio correction is enabled in
      view options. The default PAR is 1, which means square pixels. PAR values less than 1 produce pixels that are tall and skinny, while PAR
      values greater than 1 produce pixels that are fat and wide.
    </dd>
    <dd>
      The fraction need not be reduced to lowest terms, but the denominator may not be zero and the ratio should not be negative.
      PAR values are clamped to 0.01-100. The PAR is specified as a fraction to work with integers; under the hood it is simply
      converted to a floating-point value to scale the image at display time. It is not necessary to compute an exact ratio,
      nor are there any issues with large numerator or denominator values. Two significant digits of accuracy is generally fine,
      three will get within one pixel of error on a modern display.
    </dd>
    <dd>
      Note that PAR (pixel aspect ratio) should not be confused with DAR (display aspect ratio), the latter being referred to
      when calling displays 4:3 or 16:9. The PAR is not determined by the resolution of the display image in pixels or the
      shape of the screen. In hardware, the PAR is determined by the dot clock (pixel clock) and the horizontal and vertical
      frequency timing. 320x192 and 320x240 screens with the same H/V timing and dot clock have the same PAR.
    </dd>
    <dd>
      For an NTSC output, a common dot clock is 7.16MHz or twice the color subcarrier frequency, which produces
      a "lores" display of around 280-320 pixels across and a PAR of 6/7. This is the rate used by an ANTIC mode F screen.
      A "hires" 640 display with a 14.28MHz dot clock would have a PAR of 6/14. For PAL, the ANTIC mode F equivalent is
      a dot clock of 7.10MHz and a PAR of 1.0396. For other dot clocks, the PAR can be computed by dividing the standard square pixel
      rates of 12.273MHz (NTSC) or 14.75MHz (PAL) by the dot clock, and then dividing the result by two
      if the display is non-interlaced.
    </dd>

    <dt>void set_image(Image *image);</dt>
    <dd>
      Sets the image used as the framebuffer for the video output. This must be called before the video output can display
      a signal.
    </dd>

    <dt>void mark_active();</dt>
    <dd>
      Marks a video output as being <i>active</i>, which means there is "interesting activity" in the video output. This is
      used to aid in automatically detecting and switching to the video output when it is first used. For instance, the
      built-in XEP80 emulation uses this to automatically switch to the XEP80's output when it is initialized and
      video output autoswitching is enabled. A video output should be marked active whenever any program output is sent
      to the display. It should not be automatically marked as active on reset unless the video output was originally
      usable in that way, such as the firmware automatically initializing and activating the display.
    </dd>
    
    <dt>void set_pass_through(int enabled);</dt>
    <dd>
      Enables <i>pass-through</i> for a video output, causing the computer's normal ANTIC+GTIA output to appear through
      this video output. This is used for video outputs that actually have pass-through capability in hardware, particularly
      ones under software control. It should not be used for video outputs that were manually switched and can be simultaneously
      active like the XEP80, as this would prevent dual-monitor usage.
    </dd>

    <dt>void set_text_area(int columns, int rows);</dt>
    <dd>
      Sets the dimensions for a character grid of the video output, in terms of a regular grid of characters mapped over the size of
      the display output. For instance, <tt>set_text_area(80, 24)</tt> on a 640x192 display would declare the text
      mapping to be 24 rows of 80 characters, with an 8x8 cell per character. The character grid size does not have
      to evenly divide into the image size, though this is recommended to avoid rounding errors.
    </dd>
    <dd>
      The character grid is used to enable text selection and text copy from the custom output. It does not affect
      the display output or generate a text screen image. Once set, character spans can be drag-selected on screen
      and copy requests issued to read out the text, with <tt>pre_copy</tt> and <tt>set_copy_text_source()</tt>
      assisting. Setting a grid size of 0x0 will disable text selection.
    </dd>

    <dt>void set_copy_text_source(Segment *seg, int offset, int skip);</dt>
    <dd>
      Sets a segment region to read ATASCII characters out of when a text copy operation is performed. This should occur
      either when the video output is set up or on the <tt>pre_copy</tt> event, depending on how dynamic the video mode
      is. When the character grid and text source are set up, a copy operation will read ATASCII characters from the
      segment and translate them to text to place into the clipboard.
    </dd>
    <dd>
      <tt>offset</tt> specifies the starting offset of the character map, which is assumed to have the column and
      row counts specified to <tt>set_text_area()</tt>. <tt>skip</tt> specifies the number of bytes between the end
      of a row and the start of the next, with 0 indicating back-to-back rows. For instance, an 80x24 text area with
      skip=0 requires a contiguous 1920 byte region. The entire region must be contained within the segment for
      a copy operation to succeed, but it is OK for the mapping to be temporarily invalid since <tt>set_text_area()</tt>
      and <tt>set_copy_text_source()</tt> must be called separately. For cases where this mapping is inconvenient,
      the <tt>pre_copy</tt> event allows script to translate from the running format of the framebuffer to a copyable
      text buffer.
    </dd>
  </dl>

</topic>