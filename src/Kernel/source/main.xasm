;	Altirra - Atari 800/800XL emulator
;	Kernel ROM replacement
;	Copyright (C) 2008 Avery Lee
;
;	This program is free software; you can redistribute it and/or modify
;	it under the terms of the GNU General Public License as published by
;	the Free Software Foundation; either version 2 of the License, or
;	(at your option) any later version.
;
;	This program is distributed in the hope that it will be useful,
;	but WITHOUT ANY WARRANTY; without even the implied warranty of
;	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;	GNU General Public License for more details.
;
;	You should have received a copy of the GNU General Public License
;	along with this program; if not, write to the Free Software
;	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

trig0	equ	$d010
trig1	equ	$d011
trig2	equ	$d012
colpm0	equ	$d012
trig3	equ	$d013
colpm1	equ	$d013
colpm2	equ	$d014
colpm3	equ	$d015
colpf0	equ	$d016
colpf1	equ	$d017
colpf2	equ	$d018
colpf3	equ	$d019
colbk	equ	$d01a
prior	equ	$d01b
consol	equ	$d01f
pot0	equ	$d200
audf1	equ	$d200
pot1	equ	$d201
audc1	equ	$d201
pot2	equ	$d202
audf2	equ	$d202
pot3	equ	$d203
audc2	equ	$d203
pot4	equ	$d204
audf3	equ	$d204
pot5	equ	$d205
audc3	equ	$d205
pot6	equ	$d206
audf4	equ	$d206
pot7	equ	$d207
audc4	equ	$d207
audctl	equ	$d208
kbcode	equ	$d209
skres	equ	$d20a
serin	equ	$d20d
serout	equ	$d20d
irqen	equ	$d20e
irqst	equ	$d20e
skctl	equ	$d20f
porta	equ	$d300
portb	equ	$d301
pactl	equ	$d302
pbctl	equ	$d303
dmactl	equ	$d400
chactl	equ	$d401
dlistl	equ	$d402
dlisth	equ	$d403
hscrol	equ	$d404
vscrol	equ	$d405
chbase	equ	$d409
wsync	equ	$d40a
nmien	equ	$d40e
nmist	equ	$d40f
nmires	equ	$d40f

	opt		o-

casini	= $0002			;cassette initialization vector
tramsz	= $0006			;temporary ram size / cart A flag
tstdat	= $0007			;RAM test data register / cart B flag
warmst	= $0008			;warmstart flag
boot?	= $0009			;boot flag; 0 if none, 1 for disk, 2 for cassette
dosvec	= $000a
dosini	= $000c
pokmsk	= $0010
brkkey	= $0011			;set on [BREAK]
rtclok	= $0012
a0		= $0015
bufadr	= $0015			;indirect buffer address pointer (temp for disk buffer)
		; $0016
ziocb	= $0020			;zero-page IOCB
ichidz	= $0020			;Zero page IOCB: device index ($FF = not open)
icdnoz	= $0021			;Zero page IOCB: device number
iccomz	= $0022			;Zero page IOCB: command byte
icstaz	= $0023			;Zero page IOCB: status byte
icbalz	= $0024			;Zero page IOCB: address of device/filename spec lo
icbahz	= $0025			;Zero page IOCB: address of device/filename spec hi
icptlz	= $0026			;Zero page IOCB: put byte address lo (-1)
icpthz	= $0027			;Zero page IOCB: put byte address hi (-1)
icbllz	= $0028			;Zero page IOCB: buffer length/byte count lo (-1)
icblhz	= $0029			;Zero page IOCB: buffer length/byte count hi (-1)
icax1z	= $002a			;Zero page IOCB: device-specific information 1
icax2z	= $002b			;Zero page IOCB: device-specific information 2
icidno	= $002e			;CIO: call X register save/restore
ciochr	= $002f			;CIO: call A register save/restore
status  = $0030			;SIO: temporay status byte
chksum	= $0031			;SIO: temporary checksum byte (used by IRQ routines)
bufrlo	= $0032			;SIO: buffer pointer lo (incremented by IRQ routines)
bufrhi	= $0033			;SIO: buffer pointer hi (incremented by IRQ routines)
bfenlo	= $0034			;SIO: buffer end lo
bfenhi	= $0035			;SIO: buffer end hi
bufrfl	= $0038			;SIO: buffer full flag
recvdn	= $0039			;SIO: receive completed flag
xmtdon	= $003a			;SIO: transmit completed flag
chksnt	= $003b			;SIO: checksum sent flag
nocksm	= $003c			;SIO: no-checksum flag
critic	= $0042			;critical flag for vbi
ckey	= $004a			;cassette boot key
atract	= $004d			;screen attract counter
drkmsk	= $004e			;screen attract mask
colrsh	= $004f			;screen attract color shift
lmargn	= $0052			;left margin column
rmargn	= $0053			;right margin column
rowcrs	= $0054			;cursor row
colcrs	= $0055			;cursor column
		; $0056
savmsc	= $0058			;lowest address of screen region
oldchr	= $005d			;cursor character save/restore
oldadr	= $005e			;cursor memory address
adress	= $0064			;temporary storage (display code)
		; $0065
a1		= adress
ramtop	= $006a			;ram size
holdch	= $007c			;temporary key hold area prior to shift/control lock logic

vdslst	= $0200			;display list interrupt vector
vprced	= $0202			;serial bus proceed interrupt vector
vinter	= $0204			;serial bus interrupt vector
vbreak	= $0206			;BRK instruction vector
vkeybd	= $0208			;keyboard interrupt vector
vserin	= $020a			;serial input ready interrupt vector
vseror	= $020c			;serial output ready interrupt vector
vseroc	= $020e			;serial output completed interrupt vector
vtimr1	= $0210			;pokey timer 1 interrupt vector
vtimr2	= $0212			;pokey timer 2 interrupt vector
vtimr4	= $0214			;pokey timer 4 interrupt vector
vimirq	= $0216			;immediate IRQ vector
cdtmv1	= $0218			;countdown timer 1
cdtmv2	= $021a			;countdown timer 2
cdtmv3	= $021c			;countdown timer 3
cdtmv4	= $021e			;countdown timer 4
cdtmv5	= $0220			;countdown timer 5
vvblki	= $0222			;vertical blank immediate vector
vvblkd	= $0224			;vertical blank deferred vector
cdtma1	= $0226			;timer 1 vector
cdtma2	= $0228			;timer 2 vector
cdtmf3	= $022a			;timer 3 flag
srtimr	= $022b			;autorepeat timer
cdtmf4	= $022c			;timer 4 flag
intemp	= $022d			;temp value used by SETVBV
cdtmf5	= $022e			;timer 5 flag
sdmctl	= $022f			;shadow for DMACTL ($D400)
sdlstl	= $0230			;shadow for DLISTL ($D402)
sdlsth	= $0231			;shadow for DLISTH ($D403)
sskctl	= $0232			;shadow for SKCTL ($D20F)
brkky	= $0236			;break key interrupt vector (OS B+ only)
cdevic	= $023a			;SIO: command frame device ID
ccomnd	= $023b			;SIO: command frame command ID
caux1	= $023c			;SIO: command aux byte 1
caux2	= $023d			;SIO: command aux byte 2
temp	= $023e			;SIO: temp space
errflg	= $023f			;SIO: error flag
dflags	= $0240			;disk boot flags
dbsect	= $0241			;disk boot sector count
bootad	= $0242			;disk boot address
coldst	= $0244			;cold start flag
gprior	= $026f			;shadow for PRIOR ($D01B)
paddl0	= $0270			;shadow for POT0 ($D200)
paddl1	= $0271			;shadow for POT1 ($D201)
paddl2	= $0272			;shadow for POT2 ($D202)
paddl3	= $0273			;shadow for POT3 ($D203)
paddl4	= $0274			;shadow for POT4 ($D204)
paddl5	= $0275			;shadow for POT5 ($D205)
paddl6	= $0276			;shadow for POT6 ($D206)
paddl7	= $0277			;shadow for POT7 ($D207)
stick0	= $0278			;shadow for PORTA lo ($D300)
stick1	= $0279			;shadow for PORTA hi ($D300)
stick2	= $027A			;shadow for PORTB lo ($D302)
stick3	= $027B			;shadow for PORTB hih ($D302)
strig0	= $0284			;shadow for TRIG0 ($D001)
strig1	= $0285			;shadow for TRIG1 ($D002)
strig2	= $0286			;shadow for TRIG2 ($D003)
strig3	= $0287			;shadow for TRIG3 ($D004)
txtmsc	= $0294			;text window pointer
		; $0295
shflok	= $02be			;shift/control lock flags
botscr	= $02bf			;number of text rows in text window
pcolr0	= $02c0			;shadow for COLPM0 ($D012)
pcolr1	= $02c1			;shadow for COLPM1 ($D013)
pcolr2	= $02c2			;shadow for COLPM2 ($D014)
pcolr3	= $02c3			;shadow for COLPM3 ($D015)
color0	= $02c4			;shadow for COLPF0 ($D016)
color1	= $02c5			;shadow for COLPF1 ($D017)
color2	= $02c6			;shadow for COLPF2 ($D018)
color3	= $02c7			;shadow for COLPF3 ($D019)
color4	= $02c8			;shadow for COLBK ($D01A)
memtop	= $02e5			;highest location for programs and data
memlo	= $02e7			;base of application memory
dvstat	= $02ea			;DISK: Status request buffer area (4 bytes)
		; $02eb
		; $02ec
		; $02ed
keydel	= $02f1			;keyboard debounce delay (set to 3 vblanks per key)
ch1		= $02f2			;last keyboard code read
chact	= $02f3			;shadow for CHACTL ($D401)
chbas	= $02f4			;shadow for CHBASE ($D409)
ch		= $02fc			;keyboard FIFO byte
dspflg	= $02fe			;enable/disable of control codes by screen editor (E:)
ssflag	= $02ff			;display/screen editor suspend flag
ddevic	= $0300			;serial bus ID
dunit	= $0301			;device number
dcomnd	= $0302			;command byte
dstats	= $0303			;status byte
dbuflo	= $0304			;buffer address lo
dbufhi	= $0305			;buffer address hi
dtimlo	= $0306			;disk timeout value
dbytlo	= $0308			;byte count lo
dbythi	= $0309			;byte count hi
daux1	= $030a			;sector number lo
daux2	= $030b			;sector number hi
timflg	= $0317			;SIO: operation timeout flag (set by countdown timer 1 IRQ)
stackp	= $0318			;SIO: stack pointer save
hatabs	= $031a			;handler table
ichid	= $0340			;IOCB #0 handler ID
icdno	= $0341			;IOCB #0 device number
iccmd	= $0342			;IOCB #0 command byte
icsta	= $0343			;IOCB #0 status
icbal	= $0344			;IOCB #0 buffer address lo
icbah	= $0345			;IOCB #0 buffer address hi
icptl	= $0346			;IOCB #0 PUT address lo
icpth	= $0347			;IOCB #0 PUT address hi
icbll	= $0348			;IOCB #0 buffer length/byte count lo
icblh	= $0349			;IOCB #0 buffer length/byte count hi
icax1	= $034a			;IOCB #0 auxiliary information lo
icax2	= $034b			;IOCB #0 auxiliary information hi
icax3	= $034c			;
icax4	= $034d			;
icax5	= $034e			;
icax6	= $034f			;

	opt		h-o+f+

;	icl		'loader.xasm'

	org		$d800
:2048	dta		$12

	org		$e000
	ins		'atarifont.bin',$0,$400

	org		$e400
editrv	dta		a(EditorOpen-1)
		dta		a(EditorClose-1)
		dta		a(EditorGetByte-1)
		dta		a(EditorPutByte-1)
		dta		a(EditorGetStatus-1)
		dta		a(EditorSpecial-1)
		jmp		EditorInit
		dta		$00

screnv	dta		a(ScreenOpen-1)
		dta		a(ScreenClose-1)
		dta		a(BugCheck-1)
		dta		a(ScreenPutByte-1)
		dta		a(BugCheck-1)
		dta		a(BugCheck-1)
		jsr		BugCheck
		dta		$00

keybdv	dta		a(BugCheck-1)
		dta		a(BugCheck-1)
		dta		a(KeyboardGetByte-1)
		dta		a(BugCheck-1)
		dta		a(BugCheck-1)
		dta		a(BugCheck-1)
		jmp		KeyboardInit
		dta		$00
	
printv	dta		a(BugCheck-1)
		dta		a(BugCheck-1)
		dta		a(BugCheck-1)
		dta		a(BugCheck-1)
		dta		a(BugCheck-1)
		dta		a(BugCheck-1)
		jsr		BugCheck
		dta		$00

casetv	dta		a(BugCheck-1)
		dta		a(BugCheck-1)
		dta		a(BugCheck-1)
		dta		a(BugCheck-1)
		dta		a(BugCheck-1)
		dta		a(BugCheck-1)
		jsr		BugCheck
		dta		$00

		;vector table
		org	$e450
diskiv	jsr		BugCheck
dskinv	jmp		DiskHandler
ciov	jmp		CIO
siov	jmp		SIO
setvbv	jmp		SetVBlankVector
sysvbv	jmp		VBlankImmediate
xitvbv	jmp		VBlankDeferred
sioinv	jmp		SIOInit
sendev	jsr		BugCheck
intinv	jsr		BugCheck
cioinv	jmp		CIOInit
blkbdv	jmp		Blackboard
warmsv	jmp		WarmStart
coldsv	jmp		ColdStart
rblokv	jsr		BugCheck
csopiv	jsr		BugCheck

		;handler table
HandlerTable:
		dta		c'P',a(printv)
		dta		c'C',a(casetv)
		dta		c'E',a(editrv)
		dta		c'S',a(screnv)
		dta		c'K',a(keybdv)

	icl		'init.xasm'
	icl		'boot.xasm'
	icl		'cio.xasm'
	icl		'sio.xasm'
	icl		'screen.xasm'
	icl		'bugcheck.xasm'
	icl		'disk.xasm'
	icl		'nmi.xasm'
	icl		'irq.xasm'
	icl		'blackboard.xasm'
	icl		'editor.xasm'
	icl		'keyboard.xasm'

;==============================================================================
DefaultHandler_A_RTI:
	pla
DefaultHandler_RTI:
	rti

;==============================================================================
.proc ResetRoutine
	jmp		ColdStart
	.endp

;==============================================================================
; reset vectors
;==============================================================================
	org		$fffa
nmivec	.wo		NmiRoutine
resvec	.wo		ResetRoutine
irqvec	.wo		IrqRoutine

	end
